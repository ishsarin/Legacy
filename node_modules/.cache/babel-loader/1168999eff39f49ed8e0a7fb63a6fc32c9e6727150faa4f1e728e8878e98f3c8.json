{"ast":null,"code":"\"use strict\";\n\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.overrideHttpRules = exports.transcode = exports.isProto3OptionalField = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopyWithoutMatchedFields = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\nconst proto3OptionalName = 'proto3_optional';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field) {\n  let allowObjects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const parts = field.split('.');\n  let value = request;\n  for (const part of parts) {\n    if (typeof value !== 'object') {\n      return undefined;\n    }\n    value = value[part];\n  }\n  if (!allowObjects && typeof value === 'object' && !Array.isArray(value) && value !== null) {\n    return undefined;\n  }\n  return value;\n}\nexports.getField = getField;\nfunction deepCopyWithoutMatchedFields(request, fieldsToSkip) {\n  let fullNamePrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  if (typeof request !== 'object' || request === null) {\n    return request;\n  }\n  const copy = Object.assign({}, request);\n  for (const key in copy) {\n    if (fieldsToSkip.has(`${fullNamePrefix}${key}`)) {\n      delete copy[key];\n      continue;\n    }\n    const nextFullNamePrefix = `${fullNamePrefix}${key}.`;\n    if (Array.isArray(copy[key])) {\n      // a field of an array cannot be addressed as \"request.field\", so we omit the skipping logic for array descendants\n      copy[key] = copy[key].map(value => deepCopyWithoutMatchedFields(value, new Set()));\n    } else if (typeof copy[key] === 'object' && copy[key] !== null) {\n      copy[key] = deepCopyWithoutMatchedFields(copy[key], fieldsToSkip, nextFullNamePrefix);\n    }\n  }\n  return copy;\n}\nexports.deepCopyWithoutMatchedFields = deepCopyWithoutMatchedFields;\nfunction deleteField(request, field) {\n  const parts = field.split('.');\n  while (parts.length > 1) {\n    if (typeof request !== 'object') {\n      return;\n    }\n    const part = parts.shift();\n    request = request[part];\n  }\n  const part = parts.shift();\n  if (typeof request !== 'object') {\n    return;\n  }\n  delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  const resultList = [];\n  for (const key in request) {\n    if (Array.isArray(request[key])) {\n      for (const value of request[key]) {\n        resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n      }\n    } else if (typeof request[key] === 'object' && request[key] !== null) {\n      resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n    } else {\n      resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n    }\n  }\n  return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)).join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n  return str.split('').map(c => c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)).join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n  if (!pattern || pattern === '*') {\n    return encodeWithSlashes(fieldValue);\n  }\n  if (!pattern.includes('*') && pattern !== fieldValue) {\n    return undefined;\n  }\n  // since we're converting the pattern to a regex, make necessary precautions:\n  const regex = new RegExp('^' + escapeRegExp(pattern).replace(/\\\\\\*\\\\\\*/g, '(.+)').replace(/\\\\\\*/g, '([^/]+)') + '$');\n  if (!fieldValue.match(regex)) {\n    return undefined;\n  }\n  return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction fieldToCamelCase(field) {\n  const parts = field.split('.');\n  return parts.map(part => (0, util_1.toCamelCase)(part)).join('.');\n}\nfunction match(request, pattern) {\n  let url = pattern;\n  const matchedFields = [];\n  for (;;) {\n    const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n    if (!match) {\n      break;\n    }\n    const [, before, field, pattern, after] = match;\n    const camelCasedField = fieldToCamelCase(field);\n    matchedFields.push(fieldToCamelCase(camelCasedField));\n    const fieldValue = getField(request, camelCasedField);\n    if (fieldValue === undefined) {\n      return undefined;\n    }\n    const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n    if (appliedPattern === undefined) {\n      return undefined;\n    }\n    url = before + appliedPattern + after;\n  }\n  return {\n    matchedFields,\n    url\n  };\n}\nexports.match = match;\nfunction flattenObject(request) {\n  const result = {};\n  for (const key in request) {\n    if (request[key] === undefined) {\n      continue;\n    }\n    if (Array.isArray(request[key])) {\n      // According to the http.proto comments, a repeated field may only\n      // contain primitive types, so no extra recursion here.\n      result[key] = request[key];\n      continue;\n    }\n    if (typeof request[key] === 'object' && request[key] !== null) {\n      const nested = flattenObject(request[key]);\n      for (const nestedKey in nested) {\n        result[`${key}.${nestedKey}`] = nested[nestedKey];\n      }\n      continue;\n    }\n    result[key] = request[key];\n  }\n  return result;\n}\nexports.flattenObject = flattenObject;\nfunction isProto3OptionalField(field) {\n  return field && field.options && field.options[proto3OptionalName];\n}\nexports.isProto3OptionalField = isProto3OptionalField;\nfunction transcode(request, parsedOptions) {\n  const httpRules = [];\n  for (const option of parsedOptions) {\n    if (!(httpOptionName in option)) {\n      continue;\n    }\n    const httpRule = option[httpOptionName];\n    httpRules.push(httpRule);\n    if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n      const additionalBindings = Array.isArray(httpRule.additional_bindings) ? httpRule.additional_bindings : [httpRule.additional_bindings];\n      httpRules.push(...additionalBindings);\n    }\n  }\n  for (const httpRule of httpRules) {\n    for (const httpMethod of supportedHttpMethods) {\n      if (!(httpMethod in httpRule)) {\n        continue;\n      }\n      const pathTemplate = httpRule[httpMethod];\n      const matchResult = match(request, pathTemplate);\n      if (matchResult === undefined) {\n        continue;\n      }\n      const {\n        url,\n        matchedFields\n      } = matchResult;\n      let data = deepCopyWithoutMatchedFields(request, new Set(matchedFields));\n      if (httpRule.body === '*') {\n        return {\n          httpMethod,\n          url,\n          queryString: '',\n          data\n        };\n      }\n      // one field possibly goes to request data, others go to query string\n      const queryStringObject = data;\n      if (httpRule.body) {\n        data = getField(queryStringObject, fieldToCamelCase(httpRule.body), /*allowObjects:*/true);\n        deleteField(queryStringObject, fieldToCamelCase(httpRule.body));\n      } else {\n        data = '';\n      }\n      const queryStringComponents = buildQueryStringComponents(queryStringObject);\n      const queryString = queryStringComponents.join('&');\n      if (!data || typeof data === 'object' && Object.keys(data).length === 0) {\n        data = '';\n      }\n      return {\n        httpMethod,\n        url,\n        queryString,\n        data\n      };\n    }\n  }\n  return undefined;\n}\nexports.transcode = transcode;\n// Override the protobuf json's the http rules.\nfunction overrideHttpRules(httpRules, protoJson) {\n  for (const rule of httpRules) {\n    if (!rule.selector) {\n      continue;\n    }\n    const rpc = protoJson.lookup(rule.selector);\n    // Not support override on non-exist RPC or a RPC without an annotation.\n    // We could reconsider if we have the use case later.\n    if (!rpc || !rpc.parsedOptions) {\n      continue;\n    }\n    for (const item of rpc.parsedOptions) {\n      if (!(httpOptionName in item)) {\n        continue;\n      }\n      const httpOptions = item[httpOptionName];\n      for (const httpMethod in httpOptions) {\n        if (httpMethod in rule) {\n          if (httpMethod === 'additional_bindings') {\n            continue;\n          }\n          httpOptions[httpMethod] = rule[httpMethod];\n        }\n        if (rule.additional_bindings) {\n          httpOptions['additional_bindings'] = !httpOptions['additional_bindings'] ? [] : Array.isArray(httpOptions['additional_bindings']) ? httpOptions['additional_bindings'] : [httpOptions['additional_bindings']];\n          // Make the additional_binding to be an array if it is not.\n          httpOptions['additional_bindings'].push(...rule.additional_bindings);\n        }\n      }\n    }\n  }\n}\nexports.overrideHttpRules = overrideHttpRules;","map":{"version":3,"names":["Object","defineProperty","exports","value","overrideHttpRules","transcode","isProto3OptionalField","flattenObject","match","applyPattern","encodeWithoutSlashes","encodeWithSlashes","buildQueryStringComponents","deleteField","deepCopyWithoutMatchedFields","getField","util_1","require","httpOptionName","proto3OptionalName","supportedHttpMethods","request","field","allowObjects","arguments","length","undefined","parts","split","part","Array","isArray","fieldsToSkip","fullNamePrefix","copy","assign","key","has","nextFullNamePrefix","map","Set","shift","prefix","resultList","push","toString","str","c","encodeURIComponent","join","escapeRegExp","replace","pattern","fieldValue","includes","regex","RegExp","fieldToCamelCase","toCamelCase","url","matchedFields","before","after","camelCasedField","appliedPattern","result","nested","nestedKey","options","parsedOptions","httpRules","option","httpRule","additional_bindings","additionalBindings","httpMethod","pathTemplate","matchResult","data","body","queryString","queryStringObject","queryStringComponents","keys","protoJson","rule","selector","rpc","lookup","item","httpOptions"],"sources":["D:/html/Legacy/node_modules/google-gax/build/src/transcoding.js"],"sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.overrideHttpRules = exports.transcode = exports.isProto3OptionalField = exports.flattenObject = exports.match = exports.applyPattern = exports.encodeWithoutSlashes = exports.encodeWithSlashes = exports.buildQueryStringComponents = exports.deleteField = exports.deepCopyWithoutMatchedFields = exports.getField = void 0;\nconst util_1 = require(\"./util\");\nconst httpOptionName = '(google.api.http)';\nconst proto3OptionalName = 'proto3_optional';\n// List of methods as defined in google/api/http.proto (see HttpRule)\nconst supportedHttpMethods = ['get', 'post', 'put', 'patch', 'delete'];\nfunction getField(request, field, allowObjects = false // in most cases, we need leaf fields\n) {\n    const parts = field.split('.');\n    let value = request;\n    for (const part of parts) {\n        if (typeof value !== 'object') {\n            return undefined;\n        }\n        value = value[part];\n    }\n    if (!allowObjects &&\n        typeof value === 'object' &&\n        !Array.isArray(value) &&\n        value !== null) {\n        return undefined;\n    }\n    return value;\n}\nexports.getField = getField;\nfunction deepCopyWithoutMatchedFields(request, fieldsToSkip, fullNamePrefix = '') {\n    if (typeof request !== 'object' || request === null) {\n        return request;\n    }\n    const copy = Object.assign({}, request);\n    for (const key in copy) {\n        if (fieldsToSkip.has(`${fullNamePrefix}${key}`)) {\n            delete copy[key];\n            continue;\n        }\n        const nextFullNamePrefix = `${fullNamePrefix}${key}.`;\n        if (Array.isArray(copy[key])) {\n            // a field of an array cannot be addressed as \"request.field\", so we omit the skipping logic for array descendants\n            copy[key] = copy[key].map(value => deepCopyWithoutMatchedFields(value, new Set()));\n        }\n        else if (typeof copy[key] === 'object' && copy[key] !== null) {\n            copy[key] = deepCopyWithoutMatchedFields(copy[key], fieldsToSkip, nextFullNamePrefix);\n        }\n    }\n    return copy;\n}\nexports.deepCopyWithoutMatchedFields = deepCopyWithoutMatchedFields;\nfunction deleteField(request, field) {\n    const parts = field.split('.');\n    while (parts.length > 1) {\n        if (typeof request !== 'object') {\n            return;\n        }\n        const part = parts.shift();\n        request = request[part];\n    }\n    const part = parts.shift();\n    if (typeof request !== 'object') {\n        return;\n    }\n    delete request[part];\n}\nexports.deleteField = deleteField;\nfunction buildQueryStringComponents(request, prefix = '') {\n    const resultList = [];\n    for (const key in request) {\n        if (Array.isArray(request[key])) {\n            for (const value of request[key]) {\n                resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(value.toString())}`);\n            }\n        }\n        else if (typeof request[key] === 'object' && request[key] !== null) {\n            resultList.push(...buildQueryStringComponents(request[key], `${key}.`));\n        }\n        else {\n            resultList.push(`${prefix}${encodeWithoutSlashes(key)}=${encodeWithoutSlashes(request[key] === null ? 'null' : request[key].toString())}`);\n        }\n    }\n    return resultList;\n}\nexports.buildQueryStringComponents = buildQueryStringComponents;\nfunction encodeWithSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithSlashes = encodeWithSlashes;\nfunction encodeWithoutSlashes(str) {\n    return str\n        .split('')\n        .map(c => (c.match(/[-_.~0-9a-zA-Z/]/) ? c : encodeURIComponent(c)))\n        .join('');\n}\nexports.encodeWithoutSlashes = encodeWithoutSlashes;\nfunction escapeRegExp(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\nfunction applyPattern(pattern, fieldValue) {\n    if (!pattern || pattern === '*') {\n        return encodeWithSlashes(fieldValue);\n    }\n    if (!pattern.includes('*') && pattern !== fieldValue) {\n        return undefined;\n    }\n    // since we're converting the pattern to a regex, make necessary precautions:\n    const regex = new RegExp('^' +\n        escapeRegExp(pattern)\n            .replace(/\\\\\\*\\\\\\*/g, '(.+)')\n            .replace(/\\\\\\*/g, '([^/]+)') +\n        '$');\n    if (!fieldValue.match(regex)) {\n        return undefined;\n    }\n    return encodeWithoutSlashes(fieldValue);\n}\nexports.applyPattern = applyPattern;\nfunction fieldToCamelCase(field) {\n    const parts = field.split('.');\n    return parts.map(part => (0, util_1.toCamelCase)(part)).join('.');\n}\nfunction match(request, pattern) {\n    let url = pattern;\n    const matchedFields = [];\n    for (;;) {\n        const match = url.match(/^(.*)\\{([^}=]+)(?:=([^}]*))?\\}(.*)/);\n        if (!match) {\n            break;\n        }\n        const [, before, field, pattern, after] = match;\n        const camelCasedField = fieldToCamelCase(field);\n        matchedFields.push(fieldToCamelCase(camelCasedField));\n        const fieldValue = getField(request, camelCasedField);\n        if (fieldValue === undefined) {\n            return undefined;\n        }\n        const appliedPattern = applyPattern(pattern, fieldValue === null ? 'null' : fieldValue.toString());\n        if (appliedPattern === undefined) {\n            return undefined;\n        }\n        url = before + appliedPattern + after;\n    }\n    return { matchedFields, url };\n}\nexports.match = match;\nfunction flattenObject(request) {\n    const result = {};\n    for (const key in request) {\n        if (request[key] === undefined) {\n            continue;\n        }\n        if (Array.isArray(request[key])) {\n            // According to the http.proto comments, a repeated field may only\n            // contain primitive types, so no extra recursion here.\n            result[key] = request[key];\n            continue;\n        }\n        if (typeof request[key] === 'object' && request[key] !== null) {\n            const nested = flattenObject(request[key]);\n            for (const nestedKey in nested) {\n                result[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n            continue;\n        }\n        result[key] = request[key];\n    }\n    return result;\n}\nexports.flattenObject = flattenObject;\nfunction isProto3OptionalField(field) {\n    return field && field.options && field.options[proto3OptionalName];\n}\nexports.isProto3OptionalField = isProto3OptionalField;\nfunction transcode(request, parsedOptions) {\n    const httpRules = [];\n    for (const option of parsedOptions) {\n        if (!(httpOptionName in option)) {\n            continue;\n        }\n        const httpRule = option[httpOptionName];\n        httpRules.push(httpRule);\n        if (httpRule === null || httpRule === void 0 ? void 0 : httpRule.additional_bindings) {\n            const additionalBindings = Array.isArray(httpRule.additional_bindings)\n                ? httpRule.additional_bindings\n                : [httpRule.additional_bindings];\n            httpRules.push(...additionalBindings);\n        }\n    }\n    for (const httpRule of httpRules) {\n        for (const httpMethod of supportedHttpMethods) {\n            if (!(httpMethod in httpRule)) {\n                continue;\n            }\n            const pathTemplate = httpRule[httpMethod];\n            const matchResult = match(request, pathTemplate);\n            if (matchResult === undefined) {\n                continue;\n            }\n            const { url, matchedFields } = matchResult;\n            let data = deepCopyWithoutMatchedFields(request, new Set(matchedFields));\n            if (httpRule.body === '*') {\n                return { httpMethod, url, queryString: '', data };\n            }\n            // one field possibly goes to request data, others go to query string\n            const queryStringObject = data;\n            if (httpRule.body) {\n                data = getField(queryStringObject, fieldToCamelCase(httpRule.body), \n                /*allowObjects:*/ true);\n                deleteField(queryStringObject, fieldToCamelCase(httpRule.body));\n            }\n            else {\n                data = '';\n            }\n            const queryStringComponents = buildQueryStringComponents(queryStringObject);\n            const queryString = queryStringComponents.join('&');\n            if (!data ||\n                (typeof data === 'object' && Object.keys(data).length === 0)) {\n                data = '';\n            }\n            return { httpMethod, url, queryString, data };\n        }\n    }\n    return undefined;\n}\nexports.transcode = transcode;\n// Override the protobuf json's the http rules.\nfunction overrideHttpRules(httpRules, protoJson) {\n    for (const rule of httpRules) {\n        if (!rule.selector) {\n            continue;\n        }\n        const rpc = protoJson.lookup(rule.selector);\n        // Not support override on non-exist RPC or a RPC without an annotation.\n        // We could reconsider if we have the use case later.\n        if (!rpc || !rpc.parsedOptions) {\n            continue;\n        }\n        for (const item of rpc.parsedOptions) {\n            if (!(httpOptionName in item)) {\n                continue;\n            }\n            const httpOptions = item[httpOptionName];\n            for (const httpMethod in httpOptions) {\n                if (httpMethod in rule) {\n                    if (httpMethod === 'additional_bindings') {\n                        continue;\n                    }\n                    httpOptions[httpMethod] =\n                        rule[httpMethod];\n                }\n                if (rule.additional_bindings) {\n                    httpOptions['additional_bindings'] = !httpOptions['additional_bindings']\n                        ? []\n                        : Array.isArray(httpOptions['additional_bindings'])\n                            ? httpOptions['additional_bindings']\n                            : [httpOptions['additional_bindings']];\n                    // Make the additional_binding to be an array if it is not.\n                    httpOptions['additional_bindings'].push(...rule.additional_bindings);\n                }\n            }\n        }\n    }\n}\nexports.overrideHttpRules = overrideHttpRules;\n//# sourceMappingURL=transcoding.js.map"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,iBAAiB,GAAGF,OAAO,CAACG,SAAS,GAAGH,OAAO,CAACI,qBAAqB,GAAGJ,OAAO,CAACK,aAAa,GAAGL,OAAO,CAACM,KAAK,GAAGN,OAAO,CAACO,YAAY,GAAGP,OAAO,CAACQ,oBAAoB,GAAGR,OAAO,CAACS,iBAAiB,GAAGT,OAAO,CAACU,0BAA0B,GAAGV,OAAO,CAACW,WAAW,GAAGX,OAAO,CAACY,4BAA4B,GAAGZ,OAAO,CAACa,QAAQ,GAAG,KAAK,CAAC;AACrU,MAAMC,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,cAAc,GAAG,mBAAmB;AAC1C,MAAMC,kBAAkB,GAAG,iBAAiB;AAC5C;AACA,MAAMC,oBAAoB,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC;AACtE,SAASL,QAAQA,CAACM,OAAO,EAAEC,KAAK,EAC9B;EAAA,IADgCC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAElD,MAAMG,KAAK,GAAGL,KAAK,CAACM,KAAK,CAAC,GAAG,CAAC;EAC9B,IAAIzB,KAAK,GAAGkB,OAAO;EACnB,KAAK,MAAMQ,IAAI,IAAIF,KAAK,EAAE;IACtB,IAAI,OAAOxB,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAOuB,SAAS;IACpB;IACAvB,KAAK,GAAGA,KAAK,CAAC0B,IAAI,CAAC;EACvB;EACA,IAAI,CAACN,YAAY,IACb,OAAOpB,KAAK,KAAK,QAAQ,IACzB,CAAC2B,KAAK,CAACC,OAAO,CAAC5B,KAAK,CAAC,IACrBA,KAAK,KAAK,IAAI,EAAE;IAChB,OAAOuB,SAAS;EACpB;EACA,OAAOvB,KAAK;AAChB;AACAD,OAAO,CAACa,QAAQ,GAAGA,QAAQ;AAC3B,SAASD,4BAA4BA,CAACO,OAAO,EAAEW,YAAY,EAAuB;EAAA,IAArBC,cAAc,GAAAT,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAC5E,IAAI,OAAOH,OAAO,KAAK,QAAQ,IAAIA,OAAO,KAAK,IAAI,EAAE;IACjD,OAAOA,OAAO;EAClB;EACA,MAAMa,IAAI,GAAGlC,MAAM,CAACmC,MAAM,CAAC,CAAC,CAAC,EAAEd,OAAO,CAAC;EACvC,KAAK,MAAMe,GAAG,IAAIF,IAAI,EAAE;IACpB,IAAIF,YAAY,CAACK,GAAG,CAAE,GAAEJ,cAAe,GAAEG,GAAI,EAAC,CAAC,EAAE;MAC7C,OAAOF,IAAI,CAACE,GAAG,CAAC;MAChB;IACJ;IACA,MAAME,kBAAkB,GAAI,GAAEL,cAAe,GAAEG,GAAI,GAAE;IACrD,IAAIN,KAAK,CAACC,OAAO,CAACG,IAAI,CAACE,GAAG,CAAC,CAAC,EAAE;MAC1B;MACAF,IAAI,CAACE,GAAG,CAAC,GAAGF,IAAI,CAACE,GAAG,CAAC,CAACG,GAAG,CAACpC,KAAK,IAAIW,4BAA4B,CAACX,KAAK,EAAE,IAAIqC,GAAG,CAAC,CAAC,CAAC,CAAC;IACtF,CAAC,MACI,IAAI,OAAON,IAAI,CAACE,GAAG,CAAC,KAAK,QAAQ,IAAIF,IAAI,CAACE,GAAG,CAAC,KAAK,IAAI,EAAE;MAC1DF,IAAI,CAACE,GAAG,CAAC,GAAGtB,4BAA4B,CAACoB,IAAI,CAACE,GAAG,CAAC,EAAEJ,YAAY,EAAEM,kBAAkB,CAAC;IACzF;EACJ;EACA,OAAOJ,IAAI;AACf;AACAhC,OAAO,CAACY,4BAA4B,GAAGA,4BAA4B;AACnE,SAASD,WAAWA,CAACQ,OAAO,EAAEC,KAAK,EAAE;EACjC,MAAMK,KAAK,GAAGL,KAAK,CAACM,KAAK,CAAC,GAAG,CAAC;EAC9B,OAAOD,KAAK,CAACF,MAAM,GAAG,CAAC,EAAE;IACrB,IAAI,OAAOJ,OAAO,KAAK,QAAQ,EAAE;MAC7B;IACJ;IACA,MAAMQ,IAAI,GAAGF,KAAK,CAACc,KAAK,CAAC,CAAC;IAC1BpB,OAAO,GAAGA,OAAO,CAACQ,IAAI,CAAC;EAC3B;EACA,MAAMA,IAAI,GAAGF,KAAK,CAACc,KAAK,CAAC,CAAC;EAC1B,IAAI,OAAOpB,OAAO,KAAK,QAAQ,EAAE;IAC7B;EACJ;EACA,OAAOA,OAAO,CAACQ,IAAI,CAAC;AACxB;AACA3B,OAAO,CAACW,WAAW,GAAGA,WAAW;AACjC,SAASD,0BAA0BA,CAACS,OAAO,EAAe;EAAA,IAAbqB,MAAM,GAAAlB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACpD,MAAMmB,UAAU,GAAG,EAAE;EACrB,KAAK,MAAMP,GAAG,IAAIf,OAAO,EAAE;IACvB,IAAIS,KAAK,CAACC,OAAO,CAACV,OAAO,CAACe,GAAG,CAAC,CAAC,EAAE;MAC7B,KAAK,MAAMjC,KAAK,IAAIkB,OAAO,CAACe,GAAG,CAAC,EAAE;QAC9BO,UAAU,CAACC,IAAI,CAAE,GAAEF,MAAO,GAAEhC,oBAAoB,CAAC0B,GAAG,CAAE,IAAG1B,oBAAoB,CAACP,KAAK,CAAC0C,QAAQ,CAAC,CAAC,CAAE,EAAC,CAAC;MACtG;IACJ,CAAC,MACI,IAAI,OAAOxB,OAAO,CAACe,GAAG,CAAC,KAAK,QAAQ,IAAIf,OAAO,CAACe,GAAG,CAAC,KAAK,IAAI,EAAE;MAChEO,UAAU,CAACC,IAAI,CAAC,GAAGhC,0BAA0B,CAACS,OAAO,CAACe,GAAG,CAAC,EAAG,GAAEA,GAAI,GAAE,CAAC,CAAC;IAC3E,CAAC,MACI;MACDO,UAAU,CAACC,IAAI,CAAE,GAAEF,MAAO,GAAEhC,oBAAoB,CAAC0B,GAAG,CAAE,IAAG1B,oBAAoB,CAACW,OAAO,CAACe,GAAG,CAAC,KAAK,IAAI,GAAG,MAAM,GAAGf,OAAO,CAACe,GAAG,CAAC,CAACS,QAAQ,CAAC,CAAC,CAAE,EAAC,CAAC;IAC9I;EACJ;EACA,OAAOF,UAAU;AACrB;AACAzC,OAAO,CAACU,0BAA0B,GAAGA,0BAA0B;AAC/D,SAASD,iBAAiBA,CAACmC,GAAG,EAAE;EAC5B,OAAOA,GAAG,CACLlB,KAAK,CAAC,EAAE,CAAC,CACTW,GAAG,CAACQ,CAAC,IAAKA,CAAC,CAACvC,KAAK,CAAC,iBAAiB,CAAC,GAAGuC,CAAC,GAAGC,kBAAkB,CAACD,CAAC,CAAE,CAAC,CAClEE,IAAI,CAAC,EAAE,CAAC;AACjB;AACA/C,OAAO,CAACS,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,oBAAoBA,CAACoC,GAAG,EAAE;EAC/B,OAAOA,GAAG,CACLlB,KAAK,CAAC,EAAE,CAAC,CACTW,GAAG,CAACQ,CAAC,IAAKA,CAAC,CAACvC,KAAK,CAAC,kBAAkB,CAAC,GAAGuC,CAAC,GAAGC,kBAAkB,CAACD,CAAC,CAAE,CAAC,CACnEE,IAAI,CAAC,EAAE,CAAC;AACjB;AACA/C,OAAO,CAACQ,oBAAoB,GAAGA,oBAAoB;AACnD,SAASwC,YAAYA,CAACJ,GAAG,EAAE;EACvB,OAAOA,GAAG,CAACK,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC;AACrD;AACA,SAAS1C,YAAYA,CAAC2C,OAAO,EAAEC,UAAU,EAAE;EACvC,IAAI,CAACD,OAAO,IAAIA,OAAO,KAAK,GAAG,EAAE;IAC7B,OAAOzC,iBAAiB,CAAC0C,UAAU,CAAC;EACxC;EACA,IAAI,CAACD,OAAO,CAACE,QAAQ,CAAC,GAAG,CAAC,IAAIF,OAAO,KAAKC,UAAU,EAAE;IAClD,OAAO3B,SAAS;EACpB;EACA;EACA,MAAM6B,KAAK,GAAG,IAAIC,MAAM,CAAC,GAAG,GACxBN,YAAY,CAACE,OAAO,CAAC,CAChBD,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,CAC5BA,OAAO,CAAC,OAAO,EAAE,SAAS,CAAC,GAChC,GAAG,CAAC;EACR,IAAI,CAACE,UAAU,CAAC7C,KAAK,CAAC+C,KAAK,CAAC,EAAE;IAC1B,OAAO7B,SAAS;EACpB;EACA,OAAOhB,oBAAoB,CAAC2C,UAAU,CAAC;AAC3C;AACAnD,OAAO,CAACO,YAAY,GAAGA,YAAY;AACnC,SAASgD,gBAAgBA,CAACnC,KAAK,EAAE;EAC7B,MAAMK,KAAK,GAAGL,KAAK,CAACM,KAAK,CAAC,GAAG,CAAC;EAC9B,OAAOD,KAAK,CAACY,GAAG,CAACV,IAAI,IAAI,CAAC,CAAC,EAAEb,MAAM,CAAC0C,WAAW,EAAE7B,IAAI,CAAC,CAAC,CAACoB,IAAI,CAAC,GAAG,CAAC;AACrE;AACA,SAASzC,KAAKA,CAACa,OAAO,EAAE+B,OAAO,EAAE;EAC7B,IAAIO,GAAG,GAAGP,OAAO;EACjB,MAAMQ,aAAa,GAAG,EAAE;EACxB,SAAS;IACL,MAAMpD,KAAK,GAAGmD,GAAG,CAACnD,KAAK,CAAC,oCAAoC,CAAC;IAC7D,IAAI,CAACA,KAAK,EAAE;MACR;IACJ;IACA,MAAM,GAAGqD,MAAM,EAAEvC,KAAK,EAAE8B,OAAO,EAAEU,KAAK,CAAC,GAAGtD,KAAK;IAC/C,MAAMuD,eAAe,GAAGN,gBAAgB,CAACnC,KAAK,CAAC;IAC/CsC,aAAa,CAAChB,IAAI,CAACa,gBAAgB,CAACM,eAAe,CAAC,CAAC;IACrD,MAAMV,UAAU,GAAGtC,QAAQ,CAACM,OAAO,EAAE0C,eAAe,CAAC;IACrD,IAAIV,UAAU,KAAK3B,SAAS,EAAE;MAC1B,OAAOA,SAAS;IACpB;IACA,MAAMsC,cAAc,GAAGvD,YAAY,CAAC2C,OAAO,EAAEC,UAAU,KAAK,IAAI,GAAG,MAAM,GAAGA,UAAU,CAACR,QAAQ,CAAC,CAAC,CAAC;IAClG,IAAImB,cAAc,KAAKtC,SAAS,EAAE;MAC9B,OAAOA,SAAS;IACpB;IACAiC,GAAG,GAAGE,MAAM,GAAGG,cAAc,GAAGF,KAAK;EACzC;EACA,OAAO;IAAEF,aAAa;IAAED;EAAI,CAAC;AACjC;AACAzD,OAAO,CAACM,KAAK,GAAGA,KAAK;AACrB,SAASD,aAAaA,CAACc,OAAO,EAAE;EAC5B,MAAM4C,MAAM,GAAG,CAAC,CAAC;EACjB,KAAK,MAAM7B,GAAG,IAAIf,OAAO,EAAE;IACvB,IAAIA,OAAO,CAACe,GAAG,CAAC,KAAKV,SAAS,EAAE;MAC5B;IACJ;IACA,IAAII,KAAK,CAACC,OAAO,CAACV,OAAO,CAACe,GAAG,CAAC,CAAC,EAAE;MAC7B;MACA;MACA6B,MAAM,CAAC7B,GAAG,CAAC,GAAGf,OAAO,CAACe,GAAG,CAAC;MAC1B;IACJ;IACA,IAAI,OAAOf,OAAO,CAACe,GAAG,CAAC,KAAK,QAAQ,IAAIf,OAAO,CAACe,GAAG,CAAC,KAAK,IAAI,EAAE;MAC3D,MAAM8B,MAAM,GAAG3D,aAAa,CAACc,OAAO,CAACe,GAAG,CAAC,CAAC;MAC1C,KAAK,MAAM+B,SAAS,IAAID,MAAM,EAAE;QAC5BD,MAAM,CAAE,GAAE7B,GAAI,IAAG+B,SAAU,EAAC,CAAC,GAAGD,MAAM,CAACC,SAAS,CAAC;MACrD;MACA;IACJ;IACAF,MAAM,CAAC7B,GAAG,CAAC,GAAGf,OAAO,CAACe,GAAG,CAAC;EAC9B;EACA,OAAO6B,MAAM;AACjB;AACA/D,OAAO,CAACK,aAAa,GAAGA,aAAa;AACrC,SAASD,qBAAqBA,CAACgB,KAAK,EAAE;EAClC,OAAOA,KAAK,IAAIA,KAAK,CAAC8C,OAAO,IAAI9C,KAAK,CAAC8C,OAAO,CAACjD,kBAAkB,CAAC;AACtE;AACAjB,OAAO,CAACI,qBAAqB,GAAGA,qBAAqB;AACrD,SAASD,SAASA,CAACgB,OAAO,EAAEgD,aAAa,EAAE;EACvC,MAAMC,SAAS,GAAG,EAAE;EACpB,KAAK,MAAMC,MAAM,IAAIF,aAAa,EAAE;IAChC,IAAI,EAAEnD,cAAc,IAAIqD,MAAM,CAAC,EAAE;MAC7B;IACJ;IACA,MAAMC,QAAQ,GAAGD,MAAM,CAACrD,cAAc,CAAC;IACvCoD,SAAS,CAAC1B,IAAI,CAAC4B,QAAQ,CAAC;IACxB,IAAIA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACC,mBAAmB,EAAE;MAClF,MAAMC,kBAAkB,GAAG5C,KAAK,CAACC,OAAO,CAACyC,QAAQ,CAACC,mBAAmB,CAAC,GAChED,QAAQ,CAACC,mBAAmB,GAC5B,CAACD,QAAQ,CAACC,mBAAmB,CAAC;MACpCH,SAAS,CAAC1B,IAAI,CAAC,GAAG8B,kBAAkB,CAAC;IACzC;EACJ;EACA,KAAK,MAAMF,QAAQ,IAAIF,SAAS,EAAE;IAC9B,KAAK,MAAMK,UAAU,IAAIvD,oBAAoB,EAAE;MAC3C,IAAI,EAAEuD,UAAU,IAAIH,QAAQ,CAAC,EAAE;QAC3B;MACJ;MACA,MAAMI,YAAY,GAAGJ,QAAQ,CAACG,UAAU,CAAC;MACzC,MAAME,WAAW,GAAGrE,KAAK,CAACa,OAAO,EAAEuD,YAAY,CAAC;MAChD,IAAIC,WAAW,KAAKnD,SAAS,EAAE;QAC3B;MACJ;MACA,MAAM;QAAEiC,GAAG;QAAEC;MAAc,CAAC,GAAGiB,WAAW;MAC1C,IAAIC,IAAI,GAAGhE,4BAA4B,CAACO,OAAO,EAAE,IAAImB,GAAG,CAACoB,aAAa,CAAC,CAAC;MACxE,IAAIY,QAAQ,CAACO,IAAI,KAAK,GAAG,EAAE;QACvB,OAAO;UAAEJ,UAAU;UAAEhB,GAAG;UAAEqB,WAAW,EAAE,EAAE;UAAEF;QAAK,CAAC;MACrD;MACA;MACA,MAAMG,iBAAiB,GAAGH,IAAI;MAC9B,IAAIN,QAAQ,CAACO,IAAI,EAAE;QACfD,IAAI,GAAG/D,QAAQ,CAACkE,iBAAiB,EAAExB,gBAAgB,CAACe,QAAQ,CAACO,IAAI,CAAC,EAClE,iBAAkB,IAAI,CAAC;QACvBlE,WAAW,CAACoE,iBAAiB,EAAExB,gBAAgB,CAACe,QAAQ,CAACO,IAAI,CAAC,CAAC;MACnE,CAAC,MACI;QACDD,IAAI,GAAG,EAAE;MACb;MACA,MAAMI,qBAAqB,GAAGtE,0BAA0B,CAACqE,iBAAiB,CAAC;MAC3E,MAAMD,WAAW,GAAGE,qBAAqB,CAACjC,IAAI,CAAC,GAAG,CAAC;MACnD,IAAI,CAAC6B,IAAI,IACJ,OAAOA,IAAI,KAAK,QAAQ,IAAI9E,MAAM,CAACmF,IAAI,CAACL,IAAI,CAAC,CAACrD,MAAM,KAAK,CAAE,EAAE;QAC9DqD,IAAI,GAAG,EAAE;MACb;MACA,OAAO;QAAEH,UAAU;QAAEhB,GAAG;QAAEqB,WAAW;QAAEF;MAAK,CAAC;IACjD;EACJ;EACA,OAAOpD,SAAS;AACpB;AACAxB,OAAO,CAACG,SAAS,GAAGA,SAAS;AAC7B;AACA,SAASD,iBAAiBA,CAACkE,SAAS,EAAEc,SAAS,EAAE;EAC7C,KAAK,MAAMC,IAAI,IAAIf,SAAS,EAAE;IAC1B,IAAI,CAACe,IAAI,CAACC,QAAQ,EAAE;MAChB;IACJ;IACA,MAAMC,GAAG,GAAGH,SAAS,CAACI,MAAM,CAACH,IAAI,CAACC,QAAQ,CAAC;IAC3C;IACA;IACA,IAAI,CAACC,GAAG,IAAI,CAACA,GAAG,CAAClB,aAAa,EAAE;MAC5B;IACJ;IACA,KAAK,MAAMoB,IAAI,IAAIF,GAAG,CAAClB,aAAa,EAAE;MAClC,IAAI,EAAEnD,cAAc,IAAIuE,IAAI,CAAC,EAAE;QAC3B;MACJ;MACA,MAAMC,WAAW,GAAGD,IAAI,CAACvE,cAAc,CAAC;MACxC,KAAK,MAAMyD,UAAU,IAAIe,WAAW,EAAE;QAClC,IAAIf,UAAU,IAAIU,IAAI,EAAE;UACpB,IAAIV,UAAU,KAAK,qBAAqB,EAAE;YACtC;UACJ;UACAe,WAAW,CAACf,UAAU,CAAC,GACnBU,IAAI,CAACV,UAAU,CAAC;QACxB;QACA,IAAIU,IAAI,CAACZ,mBAAmB,EAAE;UAC1BiB,WAAW,CAAC,qBAAqB,CAAC,GAAG,CAACA,WAAW,CAAC,qBAAqB,CAAC,GAClE,EAAE,GACF5D,KAAK,CAACC,OAAO,CAAC2D,WAAW,CAAC,qBAAqB,CAAC,CAAC,GAC7CA,WAAW,CAAC,qBAAqB,CAAC,GAClC,CAACA,WAAW,CAAC,qBAAqB,CAAC,CAAC;UAC9C;UACAA,WAAW,CAAC,qBAAqB,CAAC,CAAC9C,IAAI,CAAC,GAAGyC,IAAI,CAACZ,mBAAmB,CAAC;QACxE;MACJ;IACJ;EACJ;AACJ;AACAvE,OAAO,CAACE,iBAAiB,GAAGA,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}