{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentReader = void 0;\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\nclass DocumentReader {\n  /**\n   * Creates a new DocumentReader that fetches the provided documents (via\n   * `get()`).\n   *\n   * @param firestore The Firestore instance to use.\n   * @param allDocuments The documents to get.\n   */\n  constructor(firestore, allDocuments) {\n    this.firestore = firestore;\n    this.allDocuments = allDocuments;\n    this.outstandingDocuments = new Set();\n    this.retrievedDocuments = new Map();\n    for (const docRef of this.allDocuments) {\n      this.outstandingDocuments.add(docRef.formattedName);\n    }\n  }\n  /**\n   * Invokes the BatchGetDocuments RPC and returns the results.\n   *\n   * @param requestTag A unique client-assigned identifier for this request.\n   */\n  async get(requestTag) {\n    await this.fetchDocuments(requestTag);\n    // BatchGetDocuments doesn't preserve document order. We use the request\n    // order to sort the resulting documents.\n    const orderedDocuments = [];\n    for (const docRef of this.allDocuments) {\n      const document = this.retrievedDocuments.get(docRef.formattedName);\n      if (document !== undefined) {\n        // Recreate the DocumentSnapshot with the DocumentReference\n        // containing the original converter.\n        const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n        finalDoc.fieldsProto = document._fieldsProto;\n        finalDoc.readTime = document.readTime;\n        finalDoc.createTime = document.createTime;\n        finalDoc.updateTime = document.updateTime;\n        orderedDocuments.push(finalDoc.build());\n      } else {\n        throw new Error(`Did not receive document for \"${docRef.path}\".`);\n      }\n    }\n    return orderedDocuments;\n  }\n  async fetchDocuments(requestTag) {\n    if (!this.outstandingDocuments.size) {\n      return;\n    }\n    const request = {\n      database: this.firestore.formattedName,\n      documents: Array.from(this.outstandingDocuments)\n    };\n    if (this.transactionId) {\n      request.transaction = this.transactionId;\n    } else if (this.readTime) {\n      request.readTime = this.readTime.toProto().timestampValue;\n    }\n    if (this.fieldMask) {\n      const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n      request.mask = {\n        fieldPaths\n      };\n    }\n    let resultCount = 0;\n    try {\n      const stream = await this.firestore.requestStream('batchGetDocuments', /* bidirectional= */false, request, requestTag);\n      stream.resume();\n      for await (const response of stream) {\n        let snapshot;\n        if (response.found) {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n          snapshot = this.firestore.snapshot_(response.found, response.readTime);\n        } else {\n          (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n          snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n        }\n        const path = snapshot.ref.formattedName;\n        this.outstandingDocuments.delete(path);\n        this.retrievedDocuments.set(path, snapshot);\n        ++resultCount;\n      }\n    } catch (error) {\n      const shouldRetry =\n      // Transactional reads are retried via the transaction runner.\n      !this.transactionId &&\n      // Only retry if we made progress.\n      resultCount > 0 &&\n      // Don't retry permanent errors.\n      error.code !== undefined && !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n      if (shouldRetry) {\n        return this.fetchDocuments(requestTag);\n      } else {\n        throw error;\n      }\n    } finally {\n      (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n    }\n  }\n}\nexports.DocumentReader = DocumentReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","DocumentReader","document_1","require","util_1","logger_1","constructor","firestore","allDocuments","outstandingDocuments","Set","retrievedDocuments","Map","docRef","add","formattedName","get","requestTag","fetchDocuments","orderedDocuments","document","undefined","finalDoc","DocumentSnapshotBuilder","fieldsProto","_fieldsProto","readTime","createTime","updateTime","push","build","Error","path","size","request","database","documents","Array","from","transactionId","transaction","toProto","timestampValue","fieldMask","fieldPaths","map","fieldPath","mask","resultCount","stream","requestStream","resume","response","snapshot","found","logger","name","snapshot_","missing","ref","delete","set","error","shouldRetry","code","isPermanentRpcError"],"sources":["D:/html/Legacy/node_modules/@google-cloud/firestore/build/src/document-reader.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2021 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DocumentReader = void 0;\nconst document_1 = require(\"./document\");\nconst util_1 = require(\"./util\");\nconst logger_1 = require(\"./logger\");\n/**\n * A wrapper around BatchGetDocumentsRequest that retries request upon stream\n * failure and returns ordered results.\n *\n * @private\n * @internal\n */\nclass DocumentReader {\n    /**\n     * Creates a new DocumentReader that fetches the provided documents (via\n     * `get()`).\n     *\n     * @param firestore The Firestore instance to use.\n     * @param allDocuments The documents to get.\n     */\n    constructor(firestore, allDocuments) {\n        this.firestore = firestore;\n        this.allDocuments = allDocuments;\n        this.outstandingDocuments = new Set();\n        this.retrievedDocuments = new Map();\n        for (const docRef of this.allDocuments) {\n            this.outstandingDocuments.add(docRef.formattedName);\n        }\n    }\n    /**\n     * Invokes the BatchGetDocuments RPC and returns the results.\n     *\n     * @param requestTag A unique client-assigned identifier for this request.\n     */\n    async get(requestTag) {\n        await this.fetchDocuments(requestTag);\n        // BatchGetDocuments doesn't preserve document order. We use the request\n        // order to sort the resulting documents.\n        const orderedDocuments = [];\n        for (const docRef of this.allDocuments) {\n            const document = this.retrievedDocuments.get(docRef.formattedName);\n            if (document !== undefined) {\n                // Recreate the DocumentSnapshot with the DocumentReference\n                // containing the original converter.\n                const finalDoc = new document_1.DocumentSnapshotBuilder(docRef);\n                finalDoc.fieldsProto = document._fieldsProto;\n                finalDoc.readTime = document.readTime;\n                finalDoc.createTime = document.createTime;\n                finalDoc.updateTime = document.updateTime;\n                orderedDocuments.push(finalDoc.build());\n            }\n            else {\n                throw new Error(`Did not receive document for \"${docRef.path}\".`);\n            }\n        }\n        return orderedDocuments;\n    }\n    async fetchDocuments(requestTag) {\n        if (!this.outstandingDocuments.size) {\n            return;\n        }\n        const request = {\n            database: this.firestore.formattedName,\n            documents: Array.from(this.outstandingDocuments),\n        };\n        if (this.transactionId) {\n            request.transaction = this.transactionId;\n        }\n        else if (this.readTime) {\n            request.readTime = this.readTime.toProto().timestampValue;\n        }\n        if (this.fieldMask) {\n            const fieldPaths = this.fieldMask.map(fieldPath => fieldPath.formattedName);\n            request.mask = { fieldPaths };\n        }\n        let resultCount = 0;\n        try {\n            const stream = await this.firestore.requestStream('batchGetDocuments', \n            /* bidirectional= */ false, request, requestTag);\n            stream.resume();\n            for await (const response of stream) {\n                let snapshot;\n                if (response.found) {\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received document: %s', response.found.name);\n                    snapshot = this.firestore.snapshot_(response.found, response.readTime);\n                }\n                else {\n                    (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Document missing: %s', response.missing);\n                    snapshot = this.firestore.snapshot_(response.missing, response.readTime);\n                }\n                const path = snapshot.ref.formattedName;\n                this.outstandingDocuments.delete(path);\n                this.retrievedDocuments.set(path, snapshot);\n                ++resultCount;\n            }\n        }\n        catch (error) {\n            const shouldRetry = \n            // Transactional reads are retried via the transaction runner.\n            !this.transactionId &&\n                // Only retry if we made progress.\n                resultCount > 0 &&\n                // Don't retry permanent errors.\n                error.code !== undefined &&\n                !(0, util_1.isPermanentRpcError)(error, 'batchGetDocuments');\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'BatchGetDocuments failed with error: %s. Retrying: %s', error, shouldRetry);\n            if (shouldRetry) {\n                return this.fetchDocuments(requestTag);\n            }\n            else {\n                throw error;\n            }\n        }\n        finally {\n            (0, logger_1.logger)('DocumentReader.fetchDocuments', requestTag, 'Received %d results', resultCount);\n        }\n    }\n}\nexports.DocumentReader = DocumentReader;\n//# sourceMappingURL=document-reader.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}