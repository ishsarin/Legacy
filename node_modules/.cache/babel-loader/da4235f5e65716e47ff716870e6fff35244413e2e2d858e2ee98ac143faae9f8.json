{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nvar _Upload_instances, _Upload_gcclGcsCmd, _Upload_resetLocalBuffersCache, _Upload_addLocalBufferCache;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkUploadStatus = exports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = __importDefault(require(\"abort-controller\"));\nconst crypto_1 = require(\"crypto\");\nconst gaxios = __importStar(require(\"gaxios\"));\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst uuid = __importStar(require(\"uuid\"));\nconst util_js_1 = require(\"./util.js\");\nconst util_js_2 = require(\"./nodejs-common/util.js\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst package_json_helper_cjs_1 = require(\"./package-json-helper.cjs\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst packageJson = (0, package_json_helper_cjs_1.getPackageJSON)();\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n  constructor(cfg) {\n    var _a;\n    super(cfg);\n    _Upload_instances.add(this);\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    this.currentInvocationId = {\n      checkUploadStatus: uuid.v4(),\n      chunk: uuid.v4(),\n      uri: uuid.v4()\n    };\n    /**\n     * A cache of buffers written to this instance, ready for consuming\n     */\n    this.writeBuffers = [];\n    this.numChunksReadInRequest = 0;\n    /**\n     * An array of buffers used for caching the most recent upload chunk.\n     * We should not assume that the server received all bytes sent in the request.\n     *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n     */\n    this.localWriteCache = [];\n    this.localWriteCacheByteLength = 0;\n    this.upstreamEnded = false;\n    _Upload_gcclGcsCmd.set(this, void 0);\n    cfg = cfg || {};\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n    if (cfg.offset && !cfg.uri) {\n      throw new RangeError('Cannot provide an `offset` without providing a `uri`');\n    }\n    if (cfg.isPartialUpload && !cfg.chunkSize) {\n      throw new RangeError('Cannot set `isPartialUpload` without providing a `chunkSize`');\n    }\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    const universe = cfg.universeDomain || google_auth_library_1.DEFAULT_UNIVERSE;\n    this.apiEndpoint = `https://storage.${universe}`;\n    if (cfg.apiEndpoint && cfg.apiEndpoint !== this.apiEndpoint) {\n      this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n      const hostname = new URL(this.apiEndpoint).hostname;\n      // check if it is a domain of a known universe\n      const isDomain = hostname === universe;\n      const isDefaultUniverseDomain = hostname === google_auth_library_1.DEFAULT_UNIVERSE;\n      // check if it is a subdomain of a known universe\n      // by checking a last (universe's length + 1) of a hostname\n      const isSubDomainOfUniverse = hostname.slice(-(universe.length + 1)) === `.${universe}`;\n      const isSubDomainOfDefaultUniverse = hostname.slice(-(google_auth_library_1.DEFAULT_UNIVERSE.length + 1)) === `.${google_auth_library_1.DEFAULT_UNIVERSE}`;\n      if (!isDomain && !isDefaultUniverseDomain && !isSubDomainOfUniverse && !isSubDomainOfDefaultUniverse) {\n        // a custom, non-universe domain,\n        // use gaxios\n        this.authClient = gaxios;\n      }\n    }\n    this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n    this.bucket = cfg.bucket;\n    const cacheKeyElements = [cfg.bucket, cfg.file];\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(`${cfg.generation}`);\n    }\n    this.cacheKey = cacheKeyElements.join('/');\n    this.customRequestOptions = cfg.customRequestOptions || {};\n    this.file = cfg.file;\n    this.generation = cfg.generation;\n    this.kmsKeyName = cfg.kmsKeyName;\n    this.metadata = cfg.metadata || {};\n    this.offset = cfg.offset;\n    this.origin = cfg.origin;\n    this.params = cfg.params || {};\n    this.userProject = cfg.userProject;\n    this.chunkSize = cfg.chunkSize;\n    this.retryOptions = cfg.retryOptions;\n    this.isPartialUpload = (_a = cfg.isPartialUpload) !== null && _a !== void 0 ? _a : false;\n    if (cfg.key) {\n      const base64Key = Buffer.from(cfg.key).toString('base64');\n      this.encryption = {\n        key: base64Key,\n        hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64')\n      };\n    }\n    this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) this.predefinedAcl = 'private';\n    if (cfg.public) this.predefinedAcl = 'publicRead';\n    const autoRetry = cfg.retryOptions.autoRetry;\n    this.uriProvidedManually = !!cfg.uri;\n    this.uri = cfg.uri;\n    if (this.offset) {\n      // we're resuming an incomplete upload\n      this.numBytesWritten = this.offset;\n    }\n    this.numRetries = 0; // counter for number of retries currently executed\n    if (!autoRetry) {\n      cfg.retryOptions.maxRetries = 0;\n    }\n    this.timeOfFirstRequest = Date.now();\n    const contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n    __classPrivateFieldSet(this, _Upload_gcclGcsCmd, cfg[util_js_2.GCCL_GCS_CMD_KEY], \"f\");\n    this.once('writing', () => {\n      if (this.uri) {\n        this.continueUploading();\n      } else {\n        this.createURI(err => {\n          if (err) {\n            return this.destroy(err);\n          }\n          this.startUploading();\n          return;\n        });\n      }\n    });\n  }\n  /**\n   * Prevent 'finish' event until the upload has succeeded.\n   *\n   * @param fireFinishEvent The finish callback\n   */\n  _final() {\n    let fireFinishEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    this.upstreamEnded = true;\n    this.once('uploadFinished', fireFinishEvent);\n    process.nextTick(() => {\n      this.emit('upstreamFinished');\n      // it's possible `_write` may not be called - namely for empty object uploads\n      this.emit('writing');\n    });\n  }\n  /**\n   * Handles incoming data from upstream\n   *\n   * @param chunk The chunk to append to the buffer\n   * @param encoding The encoding of the chunk\n   * @param readCallback A callback for when the buffer has been read downstream\n   */\n  _write(chunk, encoding) {\n    let readCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n    // Backwards-compatible event\n    this.emit('writing');\n    this.writeBuffers.push(typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk);\n    this.once('readFromChunkBuffer', readCallback);\n    process.nextTick(() => this.emit('wroteToChunkBuffer'));\n  }\n  /**\n   * Prepends the local buffer to write buffer and resets it.\n   *\n   * @param keepLastBytes number of bytes to keep from the end of the local buffer.\n   */\n  prependLocalBufferToUpstream(keepLastBytes) {\n    // Typically, the upstream write buffers should be smaller than the local\n    // cache, so we can save time by setting the local cache as the new\n    // upstream write buffer array and appending the old array to it\n    let initialBuffers = [];\n    if (keepLastBytes) {\n      // we only want the last X bytes\n      let bytesKept = 0;\n      while (keepLastBytes > bytesKept) {\n        // load backwards because we want the last X bytes\n        // note: `localWriteCacheByteLength` is reset below\n        let buf = this.localWriteCache.pop();\n        if (!buf) break;\n        bytesKept += buf.byteLength;\n        if (bytesKept > keepLastBytes) {\n          // we have gone over the amount desired, let's keep the last X bytes\n          // of this buffer\n          const diff = bytesKept - keepLastBytes;\n          buf = buf.subarray(diff);\n          bytesKept -= diff;\n        }\n        initialBuffers.unshift(buf);\n      }\n    } else {\n      // we're keeping all of the local cache, simply use it as the initial buffer\n      initialBuffers = this.localWriteCache;\n    }\n    // Append the old upstream to the new\n    const append = this.writeBuffers;\n    this.writeBuffers = initialBuffers;\n    for (const buf of append) {\n      this.writeBuffers.push(buf);\n    }\n    // reset last buffers sent\n    __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n  }\n  /**\n   * Retrieves data from upstream's buffer.\n   *\n   * @param limit The maximum amount to return from the buffer.\n   */\n  *pullFromChunkBuffer(limit) {\n    while (limit) {\n      const buf = this.writeBuffers.shift();\n      if (!buf) break;\n      let bufToYield = buf;\n      if (buf.byteLength > limit) {\n        bufToYield = buf.subarray(0, limit);\n        this.writeBuffers.unshift(buf.subarray(limit));\n        limit = 0;\n      } else {\n        limit -= buf.byteLength;\n      }\n      yield bufToYield;\n      // Notify upstream we've read from the buffer and we're able to consume\n      // more. It can also potentially send more data down as we're currently\n      // iterating.\n      this.emit('readFromChunkBuffer');\n    }\n  }\n  /**\n   * A handler for determining if data is ready to be read from upstream.\n   *\n   * @returns If there will be more chunks to read in the future\n   */\n  async waitForNextChunk() {\n    const willBeMoreChunks = await new Promise(resolve => {\n      // There's data available - it should be digested\n      if (this.writeBuffers.length) {\n        return resolve(true);\n      }\n      // The upstream writable ended, we shouldn't expect any more data.\n      if (this.upstreamEnded) {\n        return resolve(false);\n      }\n      // Nothing immediate seems to be determined. We need to prepare some\n      // listeners to determine next steps...\n      const wroteToChunkBufferCallback = () => {\n        removeListeners();\n        return resolve(true);\n      };\n      const upstreamFinishedCallback = () => {\n        removeListeners();\n        // this should be the last chunk, if there's anything there\n        if (this.writeBuffers.length) return resolve(true);\n        return resolve(false);\n      };\n      // Remove listeners when we're ready to callback.\n      const removeListeners = () => {\n        this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n        this.removeListener('upstreamFinished', upstreamFinishedCallback);\n      };\n      // If there's data recently written it should be digested\n      this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n      // If the upstream finishes let's see if there's anything to grab\n      this.once('upstreamFinished', upstreamFinishedCallback);\n    });\n    return willBeMoreChunks;\n  }\n  /**\n   * Reads data from upstream up to the provided `limit`.\n   * Ends when the limit has reached or no data is expected to be pushed from upstream.\n   *\n   * @param limit The most amount of data this iterator should return. `Infinity` by default.\n   */\n  upstreamIterator() {\n    try {\n      var _this = this;\n      let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n      return async function* () {\n        // read from upstream chunk buffer\n        while (limit && (await _this.waitForNextChunk())) {\n          // read until end or limit has been reached\n          for (const chunk of _this.pullFromChunkBuffer(limit)) {\n            limit -= chunk.byteLength;\n            yield chunk;\n          }\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  createURI(callback) {\n    if (!callback) {\n      return this.createURIAsync();\n    }\n    this.createURIAsync().then(r => callback(null, r), callback);\n  }\n  async createURIAsync() {\n    const metadata = {\n      ...this.metadata\n    };\n    const headers = {};\n    // Delete content length and content type from metadata if they exist.\n    // These are headers and should not be sent as part of the metadata.\n    if (metadata.contentLength) {\n      headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n      delete metadata.contentLength;\n    }\n    if (metadata.contentType) {\n      headers['X-Upload-Content-Type'] = metadata.contentType;\n      delete metadata.contentType;\n    }\n    let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.uri}`;\n    if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n      googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n    }\n    // Check if headers already exist before creating new ones\n    const reqOpts = {\n      method: 'POST',\n      url: [this.baseURI, this.bucket, 'o'].join('/'),\n      params: Object.assign({\n        name: this.file,\n        uploadType: 'resumable'\n      }, this.params),\n      data: metadata,\n      headers: {\n        'User-Agent': (0, util_js_1.getUserAgentString)(),\n        'x-goog-api-client': googAPIClient,\n        ...headers\n      }\n    };\n    if (metadata.contentLength) {\n      reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n    }\n    if (metadata.contentType) {\n      reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n    }\n    if (typeof this.generation !== 'undefined') {\n      reqOpts.params.ifGenerationMatch = this.generation;\n    }\n    if (this.kmsKeyName) {\n      reqOpts.params.kmsKeyName = this.kmsKeyName;\n    }\n    if (this.predefinedAcl) {\n      reqOpts.params.predefinedAcl = this.predefinedAcl;\n    }\n    if (this.origin) {\n      reqOpts.headers.Origin = this.origin;\n    }\n    const uri = await (0, async_retry_1.default)(async bail => {\n      var _a, _b, _c;\n      try {\n        const res = await this.makeRequest(reqOpts);\n        // We have successfully got a URI we can now create a new invocation id\n        this.currentInvocationId.uri = uuid.v4();\n        return res.headers.location;\n      } catch (err) {\n        const e = err;\n        const apiError = {\n          code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n          name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n          message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n          errors: [{\n            reason: e.code\n          }]\n        };\n        if (this.retryOptions.maxRetries > 0 && this.retryOptions.retryableErrorFn(apiError)) {\n          throw e;\n        } else {\n          return bail(e);\n        }\n      }\n    }, {\n      retries: this.retryOptions.maxRetries,\n      factor: this.retryOptions.retryDelayMultiplier,\n      maxTimeout: this.retryOptions.maxRetryDelay * 1000,\n      //convert to milliseconds\n      maxRetryTime: this.retryOptions.totalTimeout * 1000 //convert to milliseconds\n    });\n\n    this.uri = uri;\n    this.offset = 0;\n    // emit the newly generated URI for future reuse, if necessary.\n    this.emit('uri', uri);\n    return uri;\n  }\n  async continueUploading() {\n    var _a;\n    (_a = this.offset) !== null && _a !== void 0 ? _a : await this.getAndSetOffset();\n    return this.startUploading();\n  }\n  async startUploading() {\n    const multiChunkMode = !!this.chunkSize;\n    let responseReceived = false;\n    this.numChunksReadInRequest = 0;\n    if (!this.offset) {\n      this.offset = 0;\n    }\n    // Check if the offset (server) is too far behind the current stream\n    if (this.offset < this.numBytesWritten) {\n      const delta = this.numBytesWritten - this.offset;\n      const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n      this.emit('error', new RangeError(message));\n      return;\n    }\n    // Check if we should 'fast-forward' to the relevant data to upload\n    if (this.numBytesWritten < this.offset) {\n      // 'fast-forward' to the byte where we need to upload.\n      // only push data from the byte after the one we left off on\n      const fastForwardBytes = this.offset - this.numBytesWritten;\n      for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n        _chunk; // discard the data up until the point we want\n      }\n\n      this.numBytesWritten = this.offset;\n    }\n    let expectedUploadSize = undefined;\n    // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n    if (typeof this.contentLength === 'number') {\n      expectedUploadSize = this.contentLength - this.numBytesWritten;\n    }\n    // `expectedUploadSize` should be no more than the `chunkSize`.\n    // It's possible this is the last chunk request for a multiple\n    // chunk upload, thus smaller than the chunk size.\n    if (this.chunkSize) {\n      expectedUploadSize = expectedUploadSize ? Math.min(this.chunkSize, expectedUploadSize) : this.chunkSize;\n    }\n    // A queue for the upstream data\n    const upstreamQueue = this.upstreamIterator(expectedUploadSize);\n    // The primary read stream for this request. This stream retrieves no more\n    // than the exact requested amount from upstream.\n    const requestStream = new stream_1.Readable({\n      read: async () => {\n        // Don't attempt to retrieve data upstream if we already have a response\n        if (responseReceived) requestStream.push(null);\n        const result = await upstreamQueue.next();\n        if (result.value) {\n          this.numChunksReadInRequest++;\n          if (multiChunkMode) {\n            // save ever buffer used in the request in multi-chunk mode\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n          } else {\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n          }\n          this.numBytesWritten += result.value.byteLength;\n          this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength\n          });\n          requestStream.push(result.value);\n        }\n        if (result.done) {\n          requestStream.push(null);\n        }\n      }\n    });\n    let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.chunk}`;\n    if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n      googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n    }\n    const headers = {\n      'User-Agent': (0, util_js_1.getUserAgentString)(),\n      'x-goog-api-client': googAPIClient\n    };\n    // If using multiple chunk upload, set appropriate header\n    if (multiChunkMode) {\n      // We need to know how much data is available upstream to set the `Content-Range` header.\n      // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      for await (const chunk of this.upstreamIterator(expectedUploadSize)) {\n        // This will conveniently track and keep the size of the buffers.\n        // We will reach either the expected upload size or the remainder of the stream.\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, chunk);\n      }\n      // This is the sum from the `#addLocalBufferCache` calls\n      const bytesToUpload = this.localWriteCacheByteLength;\n      // Important: we want to know if the upstream has ended and the queue is empty before\n      // unshifting data back into the queue. This way we will know if this is the last request or not.\n      const isLastChunkOfUpload = !(await this.waitForNextChunk());\n      // Important: put the data back in the queue for the actual upload\n      this.prependLocalBufferToUpstream();\n      let totalObjectSize = this.contentLength;\n      if (typeof this.contentLength !== 'number' && isLastChunkOfUpload && !this.isPartialUpload) {\n        // Let's let the server know this is the last chunk of the object since we didn't set it before.\n        totalObjectSize = bytesToUpload + this.numBytesWritten;\n      }\n      // `- 1` as the ending byte is inclusive in the request.\n      const endingByte = bytesToUpload + this.numBytesWritten - 1;\n      // `Content-Length` for multiple chunk uploads is the size of the chunk,\n      // not the overall object\n      headers['Content-Length'] = bytesToUpload;\n      headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n    } else {\n      headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n    }\n    const reqOpts = {\n      method: 'PUT',\n      url: this.uri,\n      headers,\n      body: requestStream\n    };\n    try {\n      const resp = await this.makeRequestStream(reqOpts);\n      if (resp) {\n        responseReceived = true;\n        await this.responseHandler(resp);\n      }\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  // Process the API response to look for errors that came in\n  // the response body.\n  async responseHandler(resp) {\n    if (resp.data.error) {\n      this.destroy(resp.data.error);\n      return;\n    }\n    // At this point we can safely create a new id for the chunk\n    this.currentInvocationId.chunk = uuid.v4();\n    const moreDataToUpload = await this.waitForNextChunk();\n    const shouldContinueWithNextMultiChunkRequest = this.chunkSize && resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE && resp.headers.range && moreDataToUpload;\n    /**\n     * This is true when we're expecting to upload more data in a future request,\n     * yet the upstream for the upload session has been exhausted.\n     */\n    const shouldContinueUploadInAnotherRequest = this.isPartialUpload && resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE && !moreDataToUpload;\n    if (shouldContinueWithNextMultiChunkRequest) {\n      // Use the upper value in this header to determine where to start the next chunk.\n      // We should not assume that the server received all bytes sent in the request.\n      // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const range = resp.headers.range;\n      this.offset = Number(range.split('-')[1]) + 1;\n      // We should not assume that the server received all bytes sent in the request.\n      // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const missingBytes = this.numBytesWritten - this.offset;\n      if (missingBytes) {\n        // As multi-chunk uploads send one chunk per request and pulls one\n        // chunk into the pipeline, prepending the missing bytes back should\n        // be fine for the next request.\n        this.prependLocalBufferToUpstream(missingBytes);\n        this.numBytesWritten -= missingBytes;\n      } else {\n        // No bytes missing - no need to keep the local cache\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n      }\n      // continue uploading next chunk\n      this.continueUploading();\n    } else if (!this.isSuccessfulResponse(resp.status) && !shouldContinueUploadInAnotherRequest) {\n      const err = new Error('Upload failed');\n      err.code = resp.status;\n      err.name = 'Upload failed';\n      if (resp === null || resp === void 0 ? void 0 : resp.data) {\n        err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n      }\n      this.destroy(err);\n    } else {\n      // no need to keep the cache\n      __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n      if (resp && resp.data) {\n        resp.data.size = Number(resp.data.size);\n      }\n      this.emit('metadata', resp.data);\n      // Allow the object (Upload) to continue naturally so the user's\n      // \"finish\" event fires.\n      this.emit('uploadFinished');\n    }\n  }\n  /**\n   * Check the status of an existing resumable upload.\n   *\n   * @param cfg A configuration to use. `uri` is required.\n   * @returns the current upload status\n   */\n  async checkUploadStatus() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.checkUploadStatus}`;\n    if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n      googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n    }\n    const opts = {\n      method: 'PUT',\n      url: this.uri,\n      headers: {\n        'Content-Length': 0,\n        'Content-Range': 'bytes */*',\n        'User-Agent': (0, util_js_1.getUserAgentString)(),\n        'x-goog-api-client': googAPIClient\n      }\n    };\n    try {\n      const resp = await this.makeRequest(opts);\n      // Successfully got the offset we can now create a new offset invocation id\n      this.currentInvocationId.checkUploadStatus = uuid.v4();\n      return resp;\n    } catch (e) {\n      if (config.retry === false || !(e instanceof Error) || !this.retryOptions.retryableErrorFn(e)) {\n        throw e;\n      }\n      const retryDelay = this.getRetryDelay();\n      if (retryDelay <= 0) {\n        throw e;\n      }\n      await new Promise(res => setTimeout(res, retryDelay));\n      return this.checkUploadStatus(config);\n    }\n  }\n  async getAndSetOffset() {\n    try {\n      // we want to handle retries in this method.\n      const resp = await this.checkUploadStatus({\n        retry: false\n      });\n      if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        if (typeof resp.headers.range === 'string') {\n          this.offset = Number(resp.headers.range.split('-')[1]) + 1;\n          return;\n        }\n      }\n      this.offset = 0;\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  async makeRequest(reqOpts) {\n    if (this.encryption) {\n      reqOpts.headers = reqOpts.headers || {};\n      reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n      reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n      reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n    }\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    // Let gaxios know we will handle a 308 error code ourselves.\n    reqOpts.validateStatus = status => {\n      return this.isSuccessfulResponse(status) || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n    };\n    const combinedReqOpts = {\n      ...this.customRequestOptions,\n      ...reqOpts,\n      headers: {\n        ...this.customRequestOptions.headers,\n        ...reqOpts.headers\n      }\n    };\n    const res = await this.authClient.request(combinedReqOpts);\n    if (res.data && res.data.error) {\n      throw res.data.error;\n    }\n    return res;\n  }\n  async makeRequestStream(reqOpts) {\n    const controller = new abort_controller_1.default();\n    const errorCallback = () => controller.abort();\n    this.once('error', errorCallback);\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    reqOpts.signal = controller.signal;\n    reqOpts.validateStatus = () => true;\n    const combinedReqOpts = {\n      ...this.customRequestOptions,\n      ...reqOpts,\n      headers: {\n        ...this.customRequestOptions.headers,\n        ...reqOpts.headers\n      }\n    };\n    const res = await this.authClient.request(combinedReqOpts);\n    const successfulRequest = this.onResponse(res);\n    this.removeListener('error', errorCallback);\n    return successfulRequest ? res : null;\n  }\n  /**\n   * @return {bool} is the request good?\n   */\n  onResponse(resp) {\n    if (resp.status !== 200 && this.retryOptions.retryableErrorFn({\n      code: resp.status,\n      message: resp.statusText,\n      name: resp.statusText\n    })) {\n      this.attemptDelayedRetry(resp);\n      return false;\n    }\n    this.emit('response', resp);\n    return true;\n  }\n  /**\n   * @param resp GaxiosResponse object from previous attempt\n   */\n  attemptDelayedRetry(resp) {\n    if (this.numRetries < this.retryOptions.maxRetries) {\n      if (resp.status === NOT_FOUND_STATUS_CODE && this.numChunksReadInRequest === 0) {\n        this.startUploading();\n      } else {\n        const retryDelay = this.getRetryDelay();\n        if (retryDelay <= 0) {\n          this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n          return;\n        }\n        // Unshift the local cache back in case it's needed for the next request.\n        this.numBytesWritten -= this.localWriteCacheByteLength;\n        this.prependLocalBufferToUpstream();\n        // We don't know how much data has been received by the server.\n        // `continueUploading` will recheck the offset via `getAndSetOffset`.\n        // If `offset` < `numberBytesReceived` then we will raise a RangeError\n        // as we've streamed too much data that has been missed - this should\n        // not be the case for multi-chunk uploads as `lastChunkSent` is the\n        // body of the entire request.\n        this.offset = undefined;\n        setTimeout(this.continueUploading.bind(this), retryDelay);\n      }\n      this.numRetries++;\n    } else {\n      this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n    }\n  }\n  /**\n   * The amount of time to wait before retrying the request, in milliseconds.\n   * If negative, do not retry.\n   *\n   * @returns the amount of time to wait, in milliseconds.\n   */\n  getRetryDelay() {\n    const randomMs = Math.round(Math.random() * 1000);\n    const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) * 1000 + randomMs;\n    const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 - (Date.now() - this.timeOfFirstRequest);\n    const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n    return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n  }\n  /*\n   * Prepare user-defined API endpoint for compatibility with our API.\n   */\n  sanitizeEndpoint(url) {\n    if (!exports.PROTOCOL_REGEX.test(url)) {\n      url = `https://${url}`;\n    }\n    return url.replace(/\\/+$/, ''); // Remove trailing slashes\n  }\n  /**\n   * Check if a given status code is 2xx\n   *\n   * @param status The status code to check\n   * @returns if the status is 2xx\n   */\n  isSuccessfulResponse(status) {\n    return status >= 200 && status < 300;\n  }\n}\nexports.Upload = Upload;\n_Upload_gcclGcsCmd = new WeakMap(), _Upload_instances = new WeakSet(), _Upload_resetLocalBuffersCache = function _Upload_resetLocalBuffersCache() {\n  this.localWriteCache = [];\n  this.localWriteCacheByteLength = 0;\n}, _Upload_addLocalBufferCache = function _Upload_addLocalBufferCache(buf) {\n  this.localWriteCache.push(buf);\n  this.localWriteCacheByteLength += buf.byteLength;\n};\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n  const up = new Upload(cfg);\n  if (!callback) {\n    return up.createURI();\n  }\n  up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n/**\n * Check the status of an existing resumable upload.\n *\n * @param cfg A configuration to use. `uri` is required.\n * @returns the current upload status\n */\nfunction checkUploadStatus(cfg) {\n  const up = new Upload(cfg);\n  return up.checkUploadStatus();\n}\nexports.checkUploadStatus = checkUploadStatus;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__setModuleDefault","v","value","__importStar","mod","result","prototype","hasOwnProperty","call","__classPrivateFieldSet","receiver","state","kind","f","TypeError","has","set","__classPrivateFieldGet","__importDefault","_Upload_instances","_Upload_gcclGcsCmd","_Upload_resetLocalBuffersCache","_Upload_addLocalBufferCache","exports","checkUploadStatus","createURI","upload","Upload","PROTOCOL_REGEX","abort_controller_1","require","crypto_1","gaxios","google_auth_library_1","stream_1","async_retry_1","uuid","util_js_1","util_js_2","package_json_helper_cjs_1","NOT_FOUND_STATUS_CODE","RESUMABLE_INCOMPLETE_STATUS_CODE","packageJson","getPackageJSON","Writable","constructor","cfg","_a","add","numBytesWritten","numRetries","currentInvocationId","v4","chunk","uri","writeBuffers","numChunksReadInRequest","localWriteCache","localWriteCacheByteLength","upstreamEnded","bucket","file","Error","offset","RangeError","isPartialUpload","chunkSize","authConfig","scopes","authClient","GoogleAuth","universe","universeDomain","DEFAULT_UNIVERSE","apiEndpoint","sanitizeEndpoint","hostname","URL","isDomain","isDefaultUniverseDomain","isSubDomainOfUniverse","slice","length","isSubDomainOfDefaultUniverse","baseURI","cacheKeyElements","generation","push","cacheKey","join","customRequestOptions","kmsKeyName","metadata","origin","params","userProject","retryOptions","key","base64Key","Buffer","from","toString","encryption","hash","createHash","update","digest","predefinedAcl","private","public","autoRetry","uriProvidedManually","maxRetries","timeOfFirstRequest","Date","now","contentLength","Number","NaN","isNaN","GCCL_GCS_CMD_KEY","once","continueUploading","err","destroy","startUploading","_final","fireFinishEvent","arguments","process","nextTick","emit","_write","encoding","readCallback","prependLocalBufferToUpstream","keepLastBytes","initialBuffers","bytesKept","buf","pop","byteLength","diff","subarray","unshift","append","pullFromChunkBuffer","limit","shift","bufToYield","waitForNextChunk","willBeMoreChunks","Promise","resolve","wroteToChunkBufferCallback","removeListeners","upstreamFinishedCallback","removeListener","upstreamIterator","_this","Infinity","e","reject","callback","createURIAsync","then","r","headers","contentType","googAPIClient","getRuntimeTrackingString","version","getModuleFormat","reqOpts","method","url","assign","name","uploadType","data","getUserAgentString","ifGenerationMatch","Origin","default","bail","_b","_c","res","makeRequest","location","apiError","code","response","status","statusText","message","errors","reason","retryableErrorFn","retries","factor","retryDelayMultiplier","maxTimeout","maxRetryDelay","maxRetryTime","totalTimeout","getAndSetOffset","multiChunkMode","responseReceived","delta","fastForwardBytes","_chunk","expectedUploadSize","Math","min","upstreamQueue","requestStream","Readable","read","next","bytesWritten","done","bytesToUpload","isLastChunkOfUpload","totalObjectSize","endingByte","body","resp","makeRequestStream","responseHandler","attemptDelayedRetry","error","moreDataToUpload","shouldContinueWithNextMultiChunkRequest","range","shouldContinueUploadInAnotherRequest","split","missingBytes","isSuccessfulResponse","size","config","opts","retry","retryDelay","getRetryDelay","setTimeout","validateStatus","combinedReqOpts","request","controller","errorCallback","abort","signal","successfulRequest","onResponse","bind","randomMs","round","random","waitTime","pow","maxAllowableDelayMs","maxRetryDelayMs","test","replace","WeakMap","WeakSet","up"],"sources":["D:/html/Legacy/node_modules/@google-cloud/storage/build/cjs/src/resumable-upload.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _Upload_instances, _Upload_gcclGcsCmd, _Upload_resetLocalBuffersCache, _Upload_addLocalBufferCache;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkUploadStatus = exports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = __importDefault(require(\"abort-controller\"));\nconst crypto_1 = require(\"crypto\");\nconst gaxios = __importStar(require(\"gaxios\"));\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst uuid = __importStar(require(\"uuid\"));\nconst util_js_1 = require(\"./util.js\");\nconst util_js_2 = require(\"./nodejs-common/util.js\");\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nconst package_json_helper_cjs_1 = require(\"./package-json-helper.cjs\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst packageJson = (0, package_json_helper_cjs_1.getPackageJSON)();\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n    constructor(cfg) {\n        var _a;\n        super(cfg);\n        _Upload_instances.add(this);\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        this.currentInvocationId = {\n            checkUploadStatus: uuid.v4(),\n            chunk: uuid.v4(),\n            uri: uuid.v4(),\n        };\n        /**\n         * A cache of buffers written to this instance, ready for consuming\n         */\n        this.writeBuffers = [];\n        this.numChunksReadInRequest = 0;\n        /**\n         * An array of buffers used for caching the most recent upload chunk.\n         * We should not assume that the server received all bytes sent in the request.\n         *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n         */\n        this.localWriteCache = [];\n        this.localWriteCacheByteLength = 0;\n        this.upstreamEnded = false;\n        _Upload_gcclGcsCmd.set(this, void 0);\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        if (cfg.offset && !cfg.uri) {\n            throw new RangeError('Cannot provide an `offset` without providing a `uri`');\n        }\n        if (cfg.isPartialUpload && !cfg.chunkSize) {\n            throw new RangeError('Cannot set `isPartialUpload` without providing a `chunkSize`');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        const universe = cfg.universeDomain || google_auth_library_1.DEFAULT_UNIVERSE;\n        this.apiEndpoint = `https://storage.${universe}`;\n        if (cfg.apiEndpoint && cfg.apiEndpoint !== this.apiEndpoint) {\n            this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n            const hostname = new URL(this.apiEndpoint).hostname;\n            // check if it is a domain of a known universe\n            const isDomain = hostname === universe;\n            const isDefaultUniverseDomain = hostname === google_auth_library_1.DEFAULT_UNIVERSE;\n            // check if it is a subdomain of a known universe\n            // by checking a last (universe's length + 1) of a hostname\n            const isSubDomainOfUniverse = hostname.slice(-(universe.length + 1)) === `.${universe}`;\n            const isSubDomainOfDefaultUniverse = hostname.slice(-(google_auth_library_1.DEFAULT_UNIVERSE.length + 1)) ===\n                `.${google_auth_library_1.DEFAULT_UNIVERSE}`;\n            if (!isDomain &&\n                !isDefaultUniverseDomain &&\n                !isSubDomainOfUniverse &&\n                !isSubDomainOfDefaultUniverse) {\n                // a custom, non-universe domain,\n                // use gaxios\n                this.authClient = gaxios;\n            }\n        }\n        this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.customRequestOptions = cfg.customRequestOptions || {};\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        this.chunkSize = cfg.chunkSize;\n        this.retryOptions = cfg.retryOptions;\n        this.isPartialUpload = (_a = cfg.isPartialUpload) !== null && _a !== void 0 ? _a : false;\n        if (cfg.key) {\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const autoRetry = cfg.retryOptions.autoRetry;\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri;\n        if (this.offset) {\n            // we're resuming an incomplete upload\n            this.numBytesWritten = this.offset;\n        }\n        this.numRetries = 0; // counter for number of retries currently executed\n        if (!autoRetry) {\n            cfg.retryOptions.maxRetries = 0;\n        }\n        this.timeOfFirstRequest = Date.now();\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        __classPrivateFieldSet(this, _Upload_gcclGcsCmd, cfg[util_js_2.GCCL_GCS_CMD_KEY], \"f\");\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                    return;\n                });\n            }\n        });\n    }\n    /**\n     * Prevent 'finish' event until the upload has succeeded.\n     *\n     * @param fireFinishEvent The finish callback\n     */\n    _final(fireFinishEvent = () => { }) {\n        this.upstreamEnded = true;\n        this.once('uploadFinished', fireFinishEvent);\n        process.nextTick(() => {\n            this.emit('upstreamFinished');\n            // it's possible `_write` may not be called - namely for empty object uploads\n            this.emit('writing');\n        });\n    }\n    /**\n     * Handles incoming data from upstream\n     *\n     * @param chunk The chunk to append to the buffer\n     * @param encoding The encoding of the chunk\n     * @param readCallback A callback for when the buffer has been read downstream\n     */\n    _write(chunk, encoding, readCallback = () => { }) {\n        // Backwards-compatible event\n        this.emit('writing');\n        this.writeBuffers.push(typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk);\n        this.once('readFromChunkBuffer', readCallback);\n        process.nextTick(() => this.emit('wroteToChunkBuffer'));\n    }\n    /**\n     * Prepends the local buffer to write buffer and resets it.\n     *\n     * @param keepLastBytes number of bytes to keep from the end of the local buffer.\n     */\n    prependLocalBufferToUpstream(keepLastBytes) {\n        // Typically, the upstream write buffers should be smaller than the local\n        // cache, so we can save time by setting the local cache as the new\n        // upstream write buffer array and appending the old array to it\n        let initialBuffers = [];\n        if (keepLastBytes) {\n            // we only want the last X bytes\n            let bytesKept = 0;\n            while (keepLastBytes > bytesKept) {\n                // load backwards because we want the last X bytes\n                // note: `localWriteCacheByteLength` is reset below\n                let buf = this.localWriteCache.pop();\n                if (!buf)\n                    break;\n                bytesKept += buf.byteLength;\n                if (bytesKept > keepLastBytes) {\n                    // we have gone over the amount desired, let's keep the last X bytes\n                    // of this buffer\n                    const diff = bytesKept - keepLastBytes;\n                    buf = buf.subarray(diff);\n                    bytesKept -= diff;\n                }\n                initialBuffers.unshift(buf);\n            }\n        }\n        else {\n            // we're keeping all of the local cache, simply use it as the initial buffer\n            initialBuffers = this.localWriteCache;\n        }\n        // Append the old upstream to the new\n        const append = this.writeBuffers;\n        this.writeBuffers = initialBuffers;\n        for (const buf of append) {\n            this.writeBuffers.push(buf);\n        }\n        // reset last buffers sent\n        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n    }\n    /**\n     * Retrieves data from upstream's buffer.\n     *\n     * @param limit The maximum amount to return from the buffer.\n     */\n    *pullFromChunkBuffer(limit) {\n        while (limit) {\n            const buf = this.writeBuffers.shift();\n            if (!buf)\n                break;\n            let bufToYield = buf;\n            if (buf.byteLength > limit) {\n                bufToYield = buf.subarray(0, limit);\n                this.writeBuffers.unshift(buf.subarray(limit));\n                limit = 0;\n            }\n            else {\n                limit -= buf.byteLength;\n            }\n            yield bufToYield;\n            // Notify upstream we've read from the buffer and we're able to consume\n            // more. It can also potentially send more data down as we're currently\n            // iterating.\n            this.emit('readFromChunkBuffer');\n        }\n    }\n    /**\n     * A handler for determining if data is ready to be read from upstream.\n     *\n     * @returns If there will be more chunks to read in the future\n     */\n    async waitForNextChunk() {\n        const willBeMoreChunks = await new Promise(resolve => {\n            // There's data available - it should be digested\n            if (this.writeBuffers.length) {\n                return resolve(true);\n            }\n            // The upstream writable ended, we shouldn't expect any more data.\n            if (this.upstreamEnded) {\n                return resolve(false);\n            }\n            // Nothing immediate seems to be determined. We need to prepare some\n            // listeners to determine next steps...\n            const wroteToChunkBufferCallback = () => {\n                removeListeners();\n                return resolve(true);\n            };\n            const upstreamFinishedCallback = () => {\n                removeListeners();\n                // this should be the last chunk, if there's anything there\n                if (this.writeBuffers.length)\n                    return resolve(true);\n                return resolve(false);\n            };\n            // Remove listeners when we're ready to callback.\n            const removeListeners = () => {\n                this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n                this.removeListener('upstreamFinished', upstreamFinishedCallback);\n            };\n            // If there's data recently written it should be digested\n            this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n            // If the upstream finishes let's see if there's anything to grab\n            this.once('upstreamFinished', upstreamFinishedCallback);\n        });\n        return willBeMoreChunks;\n    }\n    /**\n     * Reads data from upstream up to the provided `limit`.\n     * Ends when the limit has reached or no data is expected to be pushed from upstream.\n     *\n     * @param limit The most amount of data this iterator should return. `Infinity` by default.\n     */\n    async *upstreamIterator(limit = Infinity) {\n        // read from upstream chunk buffer\n        while (limit && (await this.waitForNextChunk())) {\n            // read until end or limit has been reached\n            for (const chunk of this.pullFromChunkBuffer(limit)) {\n                limit -= chunk.byteLength;\n                yield chunk;\n            }\n        }\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = { ...this.metadata };\n        const headers = {};\n        // Delete content length and content type from metadata if they exist.\n        // These are headers and should not be sent as part of the metadata.\n        if (metadata.contentLength) {\n            headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n            delete metadata.contentLength;\n        }\n        if (metadata.contentType) {\n            headers['X-Upload-Content-Type'] = metadata.contentType;\n            delete metadata.contentType;\n        }\n        let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.uri}`;\n        if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n            googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n        }\n        // Check if headers already exist before creating new ones\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {\n                'User-Agent': (0, util_js_1.getUserAgentString)(),\n                'x-goog-api-client': googAPIClient,\n                ...headers,\n            },\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] =\n                metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const uri = await (0, async_retry_1.default)(async (bail) => {\n            var _a, _b, _c;\n            try {\n                const res = await this.makeRequest(reqOpts);\n                // We have successfully got a URI we can now create a new invocation id\n                this.currentInvocationId.uri = uuid.v4();\n                return res.headers.location;\n            }\n            catch (err) {\n                const e = err;\n                const apiError = {\n                    code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n                    name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n                    message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n                    errors: [\n                        {\n                            reason: e.code,\n                        },\n                    ],\n                };\n                if (this.retryOptions.maxRetries > 0 &&\n                    this.retryOptions.retryableErrorFn(apiError)) {\n                    throw e;\n                }\n                else {\n                    return bail(e);\n                }\n            }\n        }, {\n            retries: this.retryOptions.maxRetries,\n            factor: this.retryOptions.retryDelayMultiplier,\n            maxTimeout: this.retryOptions.maxRetryDelay * 1000, //convert to milliseconds\n            maxRetryTime: this.retryOptions.totalTimeout * 1000, //convert to milliseconds\n        });\n        this.uri = uri;\n        this.offset = 0;\n        // emit the newly generated URI for future reuse, if necessary.\n        this.emit('uri', uri);\n        return uri;\n    }\n    async continueUploading() {\n        var _a;\n        (_a = this.offset) !== null && _a !== void 0 ? _a : (await this.getAndSetOffset());\n        return this.startUploading();\n    }\n    async startUploading() {\n        const multiChunkMode = !!this.chunkSize;\n        let responseReceived = false;\n        this.numChunksReadInRequest = 0;\n        if (!this.offset) {\n            this.offset = 0;\n        }\n        // Check if the offset (server) is too far behind the current stream\n        if (this.offset < this.numBytesWritten) {\n            const delta = this.numBytesWritten - this.offset;\n            const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n            this.emit('error', new RangeError(message));\n            return;\n        }\n        // Check if we should 'fast-forward' to the relevant data to upload\n        if (this.numBytesWritten < this.offset) {\n            // 'fast-forward' to the byte where we need to upload.\n            // only push data from the byte after the one we left off on\n            const fastForwardBytes = this.offset - this.numBytesWritten;\n            for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n                _chunk; // discard the data up until the point we want\n            }\n            this.numBytesWritten = this.offset;\n        }\n        let expectedUploadSize = undefined;\n        // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n        if (typeof this.contentLength === 'number') {\n            expectedUploadSize = this.contentLength - this.numBytesWritten;\n        }\n        // `expectedUploadSize` should be no more than the `chunkSize`.\n        // It's possible this is the last chunk request for a multiple\n        // chunk upload, thus smaller than the chunk size.\n        if (this.chunkSize) {\n            expectedUploadSize = expectedUploadSize\n                ? Math.min(this.chunkSize, expectedUploadSize)\n                : this.chunkSize;\n        }\n        // A queue for the upstream data\n        const upstreamQueue = this.upstreamIterator(expectedUploadSize);\n        // The primary read stream for this request. This stream retrieves no more\n        // than the exact requested amount from upstream.\n        const requestStream = new stream_1.Readable({\n            read: async () => {\n                // Don't attempt to retrieve data upstream if we already have a response\n                if (responseReceived)\n                    requestStream.push(null);\n                const result = await upstreamQueue.next();\n                if (result.value) {\n                    this.numChunksReadInRequest++;\n                    if (multiChunkMode) {\n                        // save ever buffer used in the request in multi-chunk mode\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n                    }\n                    else {\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n                        __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, result.value);\n                    }\n                    this.numBytesWritten += result.value.byteLength;\n                    this.emit('progress', {\n                        bytesWritten: this.numBytesWritten,\n                        contentLength: this.contentLength,\n                    });\n                    requestStream.push(result.value);\n                }\n                if (result.done) {\n                    requestStream.push(null);\n                }\n            },\n        });\n        let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.chunk}`;\n        if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n            googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n        }\n        const headers = {\n            'User-Agent': (0, util_js_1.getUserAgentString)(),\n            'x-goog-api-client': googAPIClient,\n        };\n        // If using multiple chunk upload, set appropriate header\n        if (multiChunkMode) {\n            // We need to know how much data is available upstream to set the `Content-Range` header.\n            // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            for await (const chunk of this.upstreamIterator(expectedUploadSize)) {\n                // This will conveniently track and keep the size of the buffers.\n                // We will reach either the expected upload size or the remainder of the stream.\n                __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_addLocalBufferCache).call(this, chunk);\n            }\n            // This is the sum from the `#addLocalBufferCache` calls\n            const bytesToUpload = this.localWriteCacheByteLength;\n            // Important: we want to know if the upstream has ended and the queue is empty before\n            // unshifting data back into the queue. This way we will know if this is the last request or not.\n            const isLastChunkOfUpload = !(await this.waitForNextChunk());\n            // Important: put the data back in the queue for the actual upload\n            this.prependLocalBufferToUpstream();\n            let totalObjectSize = this.contentLength;\n            if (typeof this.contentLength !== 'number' &&\n                isLastChunkOfUpload &&\n                !this.isPartialUpload) {\n                // Let's let the server know this is the last chunk of the object since we didn't set it before.\n                totalObjectSize = bytesToUpload + this.numBytesWritten;\n            }\n            // `- 1` as the ending byte is inclusive in the request.\n            const endingByte = bytesToUpload + this.numBytesWritten - 1;\n            // `Content-Length` for multiple chunk uploads is the size of the chunk,\n            // not the overall object\n            headers['Content-Length'] = bytesToUpload;\n            headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n        }\n        else {\n            headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n        }\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers,\n            body: requestStream,\n        };\n        try {\n            const resp = await this.makeRequestStream(reqOpts);\n            if (resp) {\n                responseReceived = true;\n                await this.responseHandler(resp);\n            }\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    // Process the API response to look for errors that came in\n    // the response body.\n    async responseHandler(resp) {\n        if (resp.data.error) {\n            this.destroy(resp.data.error);\n            return;\n        }\n        // At this point we can safely create a new id for the chunk\n        this.currentInvocationId.chunk = uuid.v4();\n        const moreDataToUpload = await this.waitForNextChunk();\n        const shouldContinueWithNextMultiChunkRequest = this.chunkSize &&\n            resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE &&\n            resp.headers.range &&\n            moreDataToUpload;\n        /**\n         * This is true when we're expecting to upload more data in a future request,\n         * yet the upstream for the upload session has been exhausted.\n         */\n        const shouldContinueUploadInAnotherRequest = this.isPartialUpload &&\n            resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE &&\n            !moreDataToUpload;\n        if (shouldContinueWithNextMultiChunkRequest) {\n            // Use the upper value in this header to determine where to start the next chunk.\n            // We should not assume that the server received all bytes sent in the request.\n            // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const range = resp.headers.range;\n            this.offset = Number(range.split('-')[1]) + 1;\n            // We should not assume that the server received all bytes sent in the request.\n            // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const missingBytes = this.numBytesWritten - this.offset;\n            if (missingBytes) {\n                // As multi-chunk uploads send one chunk per request and pulls one\n                // chunk into the pipeline, prepending the missing bytes back should\n                // be fine for the next request.\n                this.prependLocalBufferToUpstream(missingBytes);\n                this.numBytesWritten -= missingBytes;\n            }\n            else {\n                // No bytes missing - no need to keep the local cache\n                __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            }\n            // continue uploading next chunk\n            this.continueUploading();\n        }\n        else if (!this.isSuccessfulResponse(resp.status) &&\n            !shouldContinueUploadInAnotherRequest) {\n            const err = new Error('Upload failed');\n            err.code = resp.status;\n            err.name = 'Upload failed';\n            if (resp === null || resp === void 0 ? void 0 : resp.data) {\n                err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n            }\n            this.destroy(err);\n        }\n        else {\n            // no need to keep the cache\n            __classPrivateFieldGet(this, _Upload_instances, \"m\", _Upload_resetLocalBuffersCache).call(this);\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            // Allow the object (Upload) to continue naturally so the user's\n            // \"finish\" event fires.\n            this.emit('uploadFinished');\n        }\n    }\n    /**\n     * Check the status of an existing resumable upload.\n     *\n     * @param cfg A configuration to use. `uri` is required.\n     * @returns the current upload status\n     */\n    async checkUploadStatus(config = {}) {\n        let googAPIClient = `${(0, util_js_1.getRuntimeTrackingString)()} gccl/${packageJson.version}-${(0, util_js_1.getModuleFormat)()} gccl-invocation-id/${this.currentInvocationId.checkUploadStatus}`;\n        if (__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")) {\n            googAPIClient += ` gccl-gcs-cmd/${__classPrivateFieldGet(this, _Upload_gcclGcsCmd, \"f\")}`;\n        }\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Length': 0,\n                'Content-Range': 'bytes */*',\n                'User-Agent': (0, util_js_1.getUserAgentString)(),\n                'x-goog-api-client': googAPIClient,\n            },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            // Successfully got the offset we can now create a new offset invocation id\n            this.currentInvocationId.checkUploadStatus = uuid.v4();\n            return resp;\n        }\n        catch (e) {\n            if (config.retry === false ||\n                !(e instanceof Error) ||\n                !this.retryOptions.retryableErrorFn(e)) {\n                throw e;\n            }\n            const retryDelay = this.getRetryDelay();\n            if (retryDelay <= 0) {\n                throw e;\n            }\n            await new Promise(res => setTimeout(res, retryDelay));\n            return this.checkUploadStatus(config);\n        }\n    }\n    async getAndSetOffset() {\n        try {\n            // we want to handle retries in this method.\n            const resp = await this.checkUploadStatus({ retry: false });\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (typeof resp.headers.range === 'string') {\n                    this.offset = Number(resp.headers.range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] =\n                this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return (this.isSuccessfulResponse(status) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const combinedReqOpts = {\n            ...this.customRequestOptions,\n            ...reqOpts,\n            headers: {\n                ...this.customRequestOptions.headers,\n                ...reqOpts.headers,\n            },\n        };\n        const res = await this.authClient.request(combinedReqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        const errorCallback = () => controller.abort();\n        this.once('error', errorCallback);\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const combinedReqOpts = {\n            ...this.customRequestOptions,\n            ...reqOpts,\n            headers: {\n                ...this.customRequestOptions.headers,\n                ...reqOpts.headers,\n            },\n        };\n        const res = await this.authClient.request(combinedReqOpts);\n        const successfulRequest = this.onResponse(res);\n        this.removeListener('error', errorCallback);\n        return successfulRequest ? res : null;\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status !== 200 &&\n            this.retryOptions.retryableErrorFn({\n                code: resp.status,\n                message: resp.statusText,\n                name: resp.statusText,\n            })) {\n            this.attemptDelayedRetry(resp);\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n    /**\n     * @param resp GaxiosResponse object from previous attempt\n     */\n    attemptDelayedRetry(resp) {\n        if (this.numRetries < this.retryOptions.maxRetries) {\n            if (resp.status === NOT_FOUND_STATUS_CODE &&\n                this.numChunksReadInRequest === 0) {\n                this.startUploading();\n            }\n            else {\n                const retryDelay = this.getRetryDelay();\n                if (retryDelay <= 0) {\n                    this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n                    return;\n                }\n                // Unshift the local cache back in case it's needed for the next request.\n                this.numBytesWritten -= this.localWriteCacheByteLength;\n                this.prependLocalBufferToUpstream();\n                // We don't know how much data has been received by the server.\n                // `continueUploading` will recheck the offset via `getAndSetOffset`.\n                // If `offset` < `numberBytesReceived` then we will raise a RangeError\n                // as we've streamed too much data that has been missed - this should\n                // not be the case for multi-chunk uploads as `lastChunkSent` is the\n                // body of the entire request.\n                this.offset = undefined;\n                setTimeout(this.continueUploading.bind(this), retryDelay);\n            }\n            this.numRetries++;\n        }\n        else {\n            this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n    }\n    /**\n     * The amount of time to wait before retrying the request, in milliseconds.\n     * If negative, do not retry.\n     *\n     * @returns the amount of time to wait, in milliseconds.\n     */\n    getRetryDelay() {\n        const randomMs = Math.round(Math.random() * 1000);\n        const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) *\n            1000 +\n            randomMs;\n        const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 -\n            (Date.now() - this.timeOfFirstRequest);\n        const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n        return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n    sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n    /**\n     * Check if a given status code is 2xx\n     *\n     * @param status The status code to check\n     * @returns if the status is 2xx\n     */\n    isSuccessfulResponse(status) {\n        return status >= 200 && status < 300;\n    }\n}\nexports.Upload = Upload;\n_Upload_gcclGcsCmd = new WeakMap(), _Upload_instances = new WeakSet(), _Upload_resetLocalBuffersCache = function _Upload_resetLocalBuffersCache() {\n    this.localWriteCache = [];\n    this.localWriteCacheByteLength = 0;\n}, _Upload_addLocalBufferCache = function _Upload_addLocalBufferCache(buf) {\n    this.localWriteCache.push(buf);\n    this.localWriteCacheByteLength += buf.byteLength;\n};\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n/**\n * Check the status of an existing resumable upload.\n *\n * @param cfg A configuration to use. `uri` is required.\n * @returns the current upload status\n */\nfunction checkUploadStatus(cfg) {\n    const up = new Upload(cfg);\n    return up.checkUploadStatus();\n}\nexports.checkUploadStatus = checkUploadStatus;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}