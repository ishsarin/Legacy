{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateDocumentReference = exports.validateQueryOperator = exports.validateQueryOrder = exports.AggregateQuerySnapshot = exports.AggregateQuery = exports.CollectionReference = exports.Query = exports.QueryOptions = exports.QuerySnapshot = exports.FieldOrder = exports.DocumentReference = void 0;\nconst assert = require(\"assert\");\nconst stream_1 = require(\"stream\");\nconst deepEqual = require(\"fast-deep-equal\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst order_1 = require(\"./order\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst write_batch_1 = require(\"./write-batch\");\nconst filter_1 = require(\"./filter\");\nconst aggregate_1 = require(\"./aggregate\");\nconst query_profile_1 = require(\"./query-profile\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n * @internal\n */\nconst directionOperators = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',\n * and 'array-contains-any'.\n *\n * @private\n * @internal\n */\nconst comparisonOperators = {\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '==': 'EQUAL',\n  '!=': 'NOT_EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  in: 'IN',\n  'not-in': 'NOT_IN',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY'\n};\nconst NOOP_MESSAGE = Symbol('a noop message');\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n  /**\n   * @private\n   * @internal\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   * @param _converter The converter to use when serializing data.\n   */\n  constructor(_firestore,\n  /**\n   * @private\n   * @internal\n   **/\n  _path) {\n    let _converter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, types_1.defaultConverter)();\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @internal\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n  get formattedName() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    return this._path.toQualifiedResourcePath(projectId, databaseId).formattedName;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name DocumentReference#firestore\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   * ```\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  /**\n   * A string representing the path of the referenced document (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name DocumentReference#path\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document at '${documentReference.path}'`);\n   * });\n   * ```\n   */\n  get path() {\n    return this._path.relativeName;\n  }\n  /**\n   * The last path element of the referenced document.\n   *\n   * @type {string}\n   * @name DocumentReference#id\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name '${documentReference.id}'`);\n   * });\n   * ```\n   */\n  get id() {\n    return this._path.id;\n  }\n  /**\n   * Returns a resource path for this document.\n   * @private\n   * @internal\n   */\n  get _resourcePath() {\n    return this._path;\n  }\n  /**\n   * A reference to the collection to which this DocumentReference belongs.\n   *\n   * @name DocumentReference#parent\n   * @type {CollectionReference}\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let collectionRef = documentRef.parent;\n   *\n   * collectionRef.where('foo', '==', 'bar').get().then(results => {\n   *   console.log(`Found ${results.size} matches in parent collection`);\n   * }):\n   * ```\n   */\n  get parent() {\n    return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n  }\n  /**\n   * Reads the document referred to by this DocumentReference.\n   *\n   * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n   * DocumentSnapshot for the retrieved document on success. For missing\n   * documents, DocumentSnapshot.exists will be false. If the get() fails for\n   * other reasons, the Promise will be rejected.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.get().then(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log('Document retrieved successfully.');\n   *   }\n   * });\n   * ```\n   */\n  get() {\n    return this._firestore.getAll(this).then(_ref => {\n      let [result] = _ref;\n      return result;\n    });\n  }\n  /**\n   * Gets a [CollectionReference]{@link CollectionReference} instance\n   * that refers to the collection at the specified path.\n   *\n   * @param {string} collectionPath A slash-separated path to a collection.\n   * @returns {CollectionReference} A reference to the new\n   * subcollection.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   * let subcollection = documentRef.collection('subcollection');\n   * console.log(`Path to subcollection: ${subcollection.path}`);\n   * ```\n   */\n  collection(collectionPath) {\n    (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n    const path = this._path.append(collectionPath);\n    if (!path.isCollection) {\n      throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n    }\n    return new CollectionReference(this._firestore, path);\n  }\n  /**\n   * Fetches the subcollections that are direct children of this document.\n   *\n   * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n   * with an array of CollectionReferences.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.listCollections().then(collections => {\n   *   for (let collection of collections) {\n   *     console.log(`Found subcollection with id: ${collection.id}`);\n   *   }\n   * });\n   * ```\n   */\n  listCollections() {\n    const tag = (0, util_1.requestTag)();\n    return this.firestore.initializeIfNeeded(tag).then(() => {\n      const request = {\n        parent: this.formattedName,\n        // Setting `pageSize` to an arbitrarily large value lets the backend cap\n        // the page size (currently to 300). Note that the backend rejects\n        // MAX_INT32 (b/146883794).\n        pageSize: Math.pow(2, 16) - 1\n      };\n      return this._firestore.request('listCollectionIds', request, tag).then(collectionIds => {\n        const collections = [];\n        // We can just sort this list using the default comparator since it\n        // will only contain collection ids.\n        collectionIds.sort();\n        for (const collectionId of collectionIds) {\n          collections.push(this.collection(collectionId));\n        }\n        return collections;\n      });\n    });\n  }\n  /**\n   * Create a document with the provided object values. This will fail the write\n   * if a document exists at its location.\n   *\n   * @param {DocumentData} data An object that contains the fields and data to\n   * serialize as the document.\n   * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this create.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * documentRef.create({foo: 'bar'}).then((res) => {\n   *   console.log(`Document created at ${res.updateTime}`);\n   * }).catch((err) => {\n   *   console.log(`Failed to create document: ${err}`);\n   * });\n   * ```\n   */\n  create(data) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.create(this, data).commit().then(_ref2 => {\n      let [writeResult] = _ref2;\n      return writeResult;\n    });\n  }\n  /**\n   * Deletes the document referred to by this `DocumentReference`.\n   *\n   * A delete for a non-existing document is treated as a success (unless\n   * lastUptimeTime is provided).\n   *\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the delete if the\n   * document was last updated at a different time.\n   * @param {boolean=} precondition.exists If set, enforces that the target\n   * document must or must not exist.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * delete time.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.delete().then(() => {\n   *   console.log('Document successfully deleted.');\n   * });\n   * ```\n   */\n  delete(precondition) {\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.delete(this, precondition).commit().then(_ref3 => {\n      let [writeResult] = _ref3;\n      return writeResult;\n    });\n  }\n  /**\n   * Writes to the document referred to by this DocumentReference. If the\n   * document does not yet exist, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n   * existing document.\n   *\n   * @param {T|Partial<AppModelType>} data A map of the fields and values for\n   * the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge If true, set() merges the values specified\n   * in its data argument. Fields omitted from this set() call remain untouched.\n   * If your input sets any field to an empty map, all nested fields are\n   * overwritten.\n   * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched. If your input sets any field to\n   * an empty map, all nested fields are overwritten.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {Promise.<WriteResult>} A Promise that resolves with the\n   * write time of this set.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(res => {\n   *   console.log(`Document written at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  set(data, options) {\n    let writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    if (options) {\n      writeBatch = writeBatch.set(this, data, options);\n    } else {\n      writeBatch = writeBatch.set(this, data);\n    }\n    return writeBatch.commit().then(_ref4 => {\n      let [writeResult] = _ref4;\n      return writeResult;\n    });\n  }\n  /**\n   * Updates fields in the document referred to by this DocumentReference.\n   * If the document doesn't yet exist, the update fails and the returned\n   * Promise will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n   * fields and values with which to update the document or the path of the\n   * first field to update.\n   * @param {\n   * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n   * list of field paths and values to update or a Precondition to restrict\n   * this update.\n   * @throws {Error} If the provided input is not valid Firestore data.\n   * @returns {Promise.<WriteResult>} A Promise that resolves once the\n   * data has been successfully written to the backend.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.update({foo: 'bar'}).then(res => {\n   *   console.log(`Document updated at ${res.updateTime}`);\n   * });\n   * ```\n   */\n  update(dataOrField) {\n    for (var _len = arguments.length, preconditionOrValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      preconditionOrValues[_key - 1] = arguments[_key];\n    }\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n    const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n    return writeBatch.update(this, dataOrField, ...preconditionOrValues).commit().then(_ref5 => {\n      let [writeResult] = _ref5;\n      return writeResult;\n    });\n  }\n  /**\n   * Attaches a listener for DocumentSnapshot events.\n   *\n   * @param {documentSnapshotCallback} onNext A callback to be called every\n   * time a new `DocumentSnapshot` is available.\n   * @param {errorCallback=} onError A callback to be called if the listen fails\n   * or is cancelled. No further callbacks will occur. If unset, errors will be\n   * logged to the console.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n   *   if (documentSnapshot.exists) {\n   *     console.log(documentSnapshot.data());\n   *   }\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   * ```\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('./watch').DocumentWatch)(this.firestore, this);\n    return watch.onSnapshot((readTime, size, docs) => {\n      for (const document of docs()) {\n        if (document.ref.path === this.path) {\n          onNext(document);\n          return;\n        }\n      }\n      // The document is missing.\n      const ref = new DocumentReference(this._firestore, this._path, this._converter);\n      const document = new document_1.DocumentSnapshotBuilder(ref);\n      document.readTime = readTime;\n      onNext(document.build());\n    }, onError || console.error);\n  }\n  /**\n   * Returns true if this `DocumentReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `DocumentReference` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n  }\n  /**\n   * Converts this DocumentReference to the Firestore Proto representation.\n   *\n   * @private\n   * @internal\n   */\n  toProto() {\n    return {\n      referenceValue: this.formattedName\n    };\n  }\n  /**\n   * Applies a custom data converter to this DocumentReference, allowing you to\n   * use your own custom model objects with Firestore. When you call set(),\n   * get(), etc. on the returned DocumentReference instance, the provided\n   * converter will convert between Firestore data of type `NewDbModelType` and\n   * your custom type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A DocumentReference that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @internal\n * @class\n */\nclass FieldOrder {\n  /**\n   * @param field The name of a document field (member) on which to order query\n   * results.\n   * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n   * set the ordering direction to ascending or descending, respectively.\n   */\n  constructor(field) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ASCENDING';\n    this.field = field;\n    this.direction = direction;\n  }\n  /**\n   * Generates the proto representation for this field order.\n   * @private\n   * @internal\n   */\n  toProto() {\n    return {\n      field: {\n        fieldPath: this.field.formattedName\n      },\n      direction: this.direction\n    };\n  }\n}\nexports.FieldOrder = FieldOrder;\nclass FilterInternal {}\nclass CompositeFilterInternal extends FilterInternal {\n  constructor(filters, operator) {\n    super();\n    this.filters = filters;\n    this.operator = operator;\n    // Memoized list of all field filters that can be found by traversing the tree of filters\n    // contained in this composite filter.\n    this.memoizedFlattenedFilters = null;\n  }\n  getFilters() {\n    return this.filters;\n  }\n  isConjunction() {\n    return this.operator === 'AND';\n  }\n  getFlattenedFilters() {\n    if (this.memoizedFlattenedFilters !== null) {\n      return this.memoizedFlattenedFilters;\n    }\n    this.memoizedFlattenedFilters = this.filters.reduce((allFilters, subfilter) => allFilters.concat(subfilter.getFlattenedFilters()), []);\n    return this.memoizedFlattenedFilters;\n  }\n  toProto() {\n    if (this.filters.length === 1) {\n      return this.filters[0].toProto();\n    }\n    const proto = {\n      compositeFilter: {\n        op: this.operator,\n        filters: this.filters.map(filter => filter.toProto())\n      }\n    };\n    return proto;\n  }\n  isEqual(other) {\n    if (other instanceof CompositeFilterInternal) {\n      const otherFilters = other.getFilters();\n      return this.operator === other.operator && this.getFilters().length === other.getFilters().length && this.getFilters().every((filter, index) => filter.isEqual(otherFilters[index]));\n    } else {\n      return false;\n    }\n  }\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @internal\n * @class\n */\nclass FieldFilterInternal extends FilterInternal {\n  getFlattenedFilters() {\n    return [this];\n  }\n  getFilters() {\n    return [this];\n  }\n  /**\n   * @param serializer The Firestore serializer\n   * @param field The path of the property value to compare.\n   * @param op A comparison operation.\n   * @param value The value to which to compare the field for inclusion in a\n   * query.\n   */\n  constructor(serializer, field, op, value) {\n    super();\n    this.serializer = serializer;\n    this.field = field;\n    this.op = op;\n    this.value = value;\n  }\n  /**\n   * Returns whether this FieldFilter uses an equals comparison.\n   *\n   * @private\n   * @internal\n   */\n  isInequalityFilter() {\n    switch (this.op) {\n      case 'GREATER_THAN':\n      case 'GREATER_THAN_OR_EQUAL':\n      case 'LESS_THAN':\n      case 'LESS_THAN_OR_EQUAL':\n      case 'NOT_EQUAL':\n      case 'NOT_IN':\n        return true;\n      default:\n        return false;\n    }\n  }\n  /**\n   * Generates the proto representation for this field filter.\n   *\n   * @private\n   * @internal\n   */\n  toProto() {\n    if (typeof this.value === 'number' && isNaN(this.value)) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN'\n        }\n      };\n    }\n    if (this.value === null) {\n      return {\n        unaryFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL'\n        }\n      };\n    }\n    return {\n      fieldFilter: {\n        field: {\n          fieldPath: this.field.formattedName\n        },\n        op: this.op,\n        value: this.serializer.encodeValue(this.value)\n      }\n    };\n  }\n  isEqual(other) {\n    return other instanceof FieldFilterInternal && this.field.isEqual(other.field) && this.op === other.op && deepEqual(this.value, other.value);\n  }\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n  /**\n   * @private\n   *\n   * @param _query The originating query.\n   * @param _readTime The time when this query snapshot was obtained.\n   * @param _size The number of documents in the result set.\n   * @param docs A callback returning a sorted array of documents matching\n   * this query\n   * @param changes A callback returning a sorted array of document change\n   * events for this snapshot.\n   */\n  constructor(_query, _readTime, _size, docs, changes) {\n    this._query = _query;\n    this._readTime = _readTime;\n    this._size = _size;\n    this._materializedDocs = null;\n    this._materializedChanges = null;\n    this._docs = null;\n    this._changes = null;\n    this._docs = docs;\n    this._changes = changes;\n  }\n  /**\n   * The query on which you called get() or onSnapshot() in order to get this\n   * QuerySnapshot.\n   *\n   * @type {Query}\n   * @name QuerySnapshot#query\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.limit(10).get().then(querySnapshot => {\n   *   console.log(`Returned first batch of results`);\n   *   let query = querySnapshot.query;\n   *   return query.offset(10).get();\n   * }).then(() => {\n   *   console.log(`Returned second batch of results`);\n   * });\n   * ```\n   */\n  get query() {\n    return this._query;\n  }\n  /**\n   * An array of all the documents in this QuerySnapshot.\n   *\n   * @type {Array.<QueryDocumentSnapshot>}\n   * @name QuerySnapshot#docs\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   let docs = querySnapshot.docs;\n   *   for (let doc of docs) {\n   *     console.log(`Document found at path: ${doc.ref.path}`);\n   *   }\n   * });\n   * ```\n   */\n  get docs() {\n    if (this._materializedDocs) {\n      return this._materializedDocs;\n    }\n    this._materializedDocs = this._docs();\n    this._docs = null;\n    return this._materializedDocs;\n  }\n  /**\n   * True if there are no documents in the QuerySnapshot.\n   *\n   * @type {boolean}\n   * @name QuerySnapshot#empty\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   if (querySnapshot.empty) {\n   *     console.log('No documents found.');\n   *   }\n   * });\n   * ```\n   */\n  get empty() {\n    return this._size === 0;\n  }\n  /**\n   * The number of documents in the QuerySnapshot.\n   *\n   * @type {number}\n   * @name QuerySnapshot#size\n   * @readonly\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   console.log(`Found ${querySnapshot.size} documents.`);\n   * });\n   * ```\n   */\n  get size() {\n    return this._size;\n  }\n  /**\n   * The time this query snapshot was obtained.\n   *\n   * @type {Timestamp}\n   * @name QuerySnapshot#readTime\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then((querySnapshot) => {\n   *   let readTime = querySnapshot.readTime;\n   *   console.log(`Query results returned at '${readTime.toDate()}'`);\n   * });\n   * ```\n   */\n  get readTime() {\n    return this._readTime;\n  }\n  /**\n   * Returns an array of the documents changes since the last snapshot. If\n   * this is the first snapshot, all documents will be in the list as added\n   * changes.\n   *\n   * @return {Array.<DocumentChange>}\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.onSnapshot(querySnapshot => {\n   *   let changes = querySnapshot.docChanges();\n   *   for (let change of changes) {\n   *     console.log(`A document was ${change.type}.`);\n   *   }\n   * });\n   * ```\n   */\n  docChanges() {\n    if (this._materializedChanges) {\n      return this._materializedChanges;\n    }\n    this._materializedChanges = this._changes();\n    this._changes = null;\n    return this._materializedChanges;\n  }\n  /**\n   * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n   * method for running the same callback on each {@link QueryDocumentSnapshot}\n   * that is returned.\n   *\n   * @param {function} callback A callback to be called with a\n   * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n   * the snapshot.\n   * @param {*=} thisArg The `this` binding for the callback..\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  forEach(callback, thisArg) {\n    (0, validate_1.validateFunction)('callback', callback);\n    for (const doc of this.docs) {\n      callback.call(thisArg, doc);\n    }\n  }\n  /**\n   * Returns true if the document data in this `QuerySnapshot` is equal to the\n   * provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n   * value.\n   */\n  isEqual(other) {\n    // Since the read time is different on every query read, we explicitly\n    // ignore all metadata in this comparison.\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof QuerySnapshot)) {\n      return false;\n    }\n    if (this._size !== other._size) {\n      return false;\n    }\n    if (!this._query.isEqual(other._query)) {\n      return false;\n    }\n    if (this._materializedDocs && !this._materializedChanges) {\n      // If we have only materialized the documents, we compare them first.\n      return isArrayEqual(this.docs, other.docs) && isArrayEqual(this.docChanges(), other.docChanges());\n    }\n    // Otherwise, we compare the changes first as we expect there to be fewer.\n    return isArrayEqual(this.docChanges(), other.docChanges()) && isArrayEqual(this.docs, other.docs);\n  }\n}\nexports.QuerySnapshot = QuerySnapshot;\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\nvar LimitType;\n(function (LimitType) {\n  LimitType[LimitType[\"First\"] = 0] = \"First\";\n  LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n * @internal\n */\nclass QueryOptions {\n  constructor(parentPath, collectionId, converter, allDescendants, filters, fieldOrders, startAt, endAt, limit, limitType, offset, projection) {\n    let kindless = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;\n    let requireConsistency = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : true;\n    this.parentPath = parentPath;\n    this.collectionId = collectionId;\n    this.converter = converter;\n    this.allDescendants = allDescendants;\n    this.filters = filters;\n    this.fieldOrders = fieldOrders;\n    this.startAt = startAt;\n    this.endAt = endAt;\n    this.limit = limit;\n    this.limitType = limitType;\n    this.offset = offset;\n    this.projection = projection;\n    this.kindless = kindless;\n    this.requireConsistency = requireConsistency;\n  }\n  /**\n   * Returns query options for a collection group query.\n   * @private\n   * @internal\n   */\n  static forCollectionGroupQuery(collectionId) {\n    let converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, types_1.defaultConverter)();\n    return new QueryOptions( /*parentPath=*/path_1.ResourcePath.EMPTY, collectionId, converter, /*allDescendants=*/true, /*fieldFilters=*/[], /*fieldOrders=*/[]);\n  }\n  /**\n   * Returns query options for a single-collection query.\n   * @private\n   * @internal\n   */\n  static forCollectionQuery(collectionRef) {\n    let converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, types_1.defaultConverter)();\n    return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, /*allDescendants=*/false, /*fieldFilters=*/[], /*fieldOrders=*/[]);\n  }\n  /**\n   * Returns query options for a query that fetches all descendants under the\n   * specified reference.\n   *\n   * @private\n   * @internal\n   */\n  static forKindlessAllDescendants(parent, id) {\n    let requireConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let options = new QueryOptions(parent, id, (0, types_1.defaultConverter)(), /*allDescendants=*/true, /*fieldFilters=*/[], /*fieldOrders=*/[]);\n    options = options.with({\n      kindless: true,\n      requireConsistency\n    });\n    return options;\n  }\n  /**\n   * Returns the union of the current and the provided options.\n   * @private\n   * @internal\n   */\n  with(settings) {\n    return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.filters, this.filters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection), coalesce(settings.kindless, this.kindless), coalesce(settings.requireConsistency, this.requireConsistency));\n  }\n  withConverter(converter) {\n    return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.filters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n  }\n  hasFieldOrders() {\n    return this.fieldOrders.length > 0;\n  }\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof QueryOptions && this.parentPath.isEqual(other.parentPath) && this.filtersEqual(other.filters) && this.collectionId === other.collectionId && this.converter === other.converter && this.allDescendants === other.allDescendants && this.limit === other.limit && this.offset === other.offset && deepEqual(this.fieldOrders, other.fieldOrders) && deepEqual(this.startAt, other.startAt) && deepEqual(this.endAt, other.endAt) && deepEqual(this.projection, other.projection) && this.kindless === other.kindless && this.requireConsistency === other.requireConsistency;\n  }\n  filtersEqual(other) {\n    if (this.filters.length !== other.length) {\n      return false;\n    }\n    for (let i = 0; i < other.length; i++) {\n      if (!this.filters[i].isEqual(other[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n  /**\n   * @internal\n   * @private\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _queryOptions Options that define the query.\n   */\n  constructor(\n  /**\n   * @internal\n   * @private\n   **/\n  _firestore,\n  /**\n   * @internal\n   * @private\n   **/\n  _queryOptions) {\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = new serializer_1.Serializer(_firestore);\n    this._allowUndefined = !!this._firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * Extracts field values from the DocumentSnapshot based on the provided\n   * field order.\n   *\n   * @private\n   * @internal\n   * @param documentSnapshot The document to extract the fields from.\n   * @param fieldOrders The field order that defines what fields we should\n   * extract.\n   * @return {Array.<*>} The field values to use.\n   */\n  static _extractFieldValues(documentSnapshot, fieldOrders) {\n    const fieldValues = [];\n    for (const fieldOrder of fieldOrders) {\n      if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n        fieldValues.push(documentSnapshot.ref);\n      } else {\n        const fieldValue = documentSnapshot.get(fieldOrder.field);\n        if (fieldValue === undefined) {\n          throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');\n        } else {\n          fieldValues.push(fieldValue);\n        }\n      }\n    }\n    return fieldValues;\n  }\n  /**\n   * The [Firestore]{@link Firestore} instance for the Firestore\n   * database (useful for performing transactions, etc.).\n   *\n   * @type {Firestore}\n   * @name Query#firestore\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   let firestore = documentReference.firestore;\n   *   console.log(`Root location for document is ${firestore.formattedName}`);\n   * });\n   * ```\n   */\n  get firestore() {\n    return this._firestore;\n  }\n  where(fieldPathOrFilter, opStr, value) {\n    let filter;\n    if (fieldPathOrFilter instanceof filter_1.Filter) {\n      filter = fieldPathOrFilter;\n    } else {\n      filter = filter_1.Filter.where(fieldPathOrFilter, opStr, value);\n    }\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');\n    }\n    const parsedFilter = this._parseFilter(filter);\n    if (parsedFilter.getFilters().length === 0) {\n      // Return the existing query if not adding any more filters (e.g. an empty composite filter).\n      return this;\n    }\n    const options = this._queryOptions.with({\n      filters: this._queryOptions.filters.concat(parsedFilter)\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseFilter(filter) {\n    if (filter instanceof filter_1.UnaryFilter) {\n      return this._parseFieldFilter(filter);\n    }\n    return this._parseCompositeFilter(filter);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseFieldFilter(fieldFilterData) {\n    let value = fieldFilterData._getValue();\n    let operator = fieldFilterData._getOperator();\n    const fieldPath = fieldFilterData._getField();\n    (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n    operator = validateQueryOperator('opStr', operator, value);\n    validateQueryValue('value', value, this._allowUndefined);\n    const path = path_1.FieldPath.fromArgument(fieldPath);\n    if (path_1.FieldPath.documentId().isEqual(path)) {\n      if (operator === 'array-contains' || operator === 'array-contains-any') {\n        throw new Error(`Invalid Query. You can't perform '${operator}' ` + 'queries on FieldPath.documentId().');\n      } else if (operator === 'in' || operator === 'not-in') {\n        if (!Array.isArray(value) || value.length === 0) {\n          throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);\n        }\n        value = value.map(el => this.validateReference(el));\n      } else {\n        value = this.validateReference(value);\n      }\n    }\n    return new FieldFilterInternal(this._serializer, path, comparisonOperators[operator], value);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _parseCompositeFilter(compositeFilterData) {\n    const parsedFilters = compositeFilterData._getFilters().map(filter => this._parseFilter(filter)).filter(parsedFilter => parsedFilter.getFilters().length > 0);\n    // For composite filters containing 1 filter, return the only filter.\n    // For example: AND(FieldFilter1) == FieldFilter1\n    if (parsedFilters.length === 1) {\n      return parsedFilters[0];\n    }\n    return new CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} instance that applies a\n   * field mask to the result and returns only the specified subset of fields.\n   * You can specify a list of field paths to return, or use an empty list to\n   * only return the references of matching documents.\n   *\n   * Queries that contain field masks cannot be listened to via `onSnapshot()`\n   * listeners.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   * let documentRef = collectionRef.doc('doc');\n   *\n   * return documentRef.set({x:10, y:5}).then(() => {\n   *   return collectionRef.where('x', '>', 5).select('y').get();\n   * }).then((res) => {\n   *   console.log(`y is ${res.docs[0].get('y')}.`);\n   * });\n   * ```\n   */\n  select() {\n    const fields = [];\n    if (arguments.length === 0) {\n      fields.push({\n        fieldPath: path_1.FieldPath.documentId().formattedName\n      });\n    } else {\n      for (let i = 0; i < arguments.length; ++i) {\n        (0, path_1.validateFieldPath)(i, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n        fields.push({\n          fieldPath: path_1.FieldPath.fromArgument(i < 0 || arguments.length <= i ? undefined : arguments[i]).formattedName\n        });\n      }\n    }\n    // By specifying a field mask, the query result no longer conforms to type\n    // `T`. We there return `Query<DocumentData>`;\n    const options = this._queryOptions.with({\n      projection: {\n        fields\n      }\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that's additionally sorted\n   * by the specified field, optionally in descending order instead of\n   * ascending.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the field mask.\n   *\n   * @param {string|FieldPath} fieldPath The field to sort by.\n   * @param {string=} directionStr Optional direction to sort by ('asc' or\n   * 'desc'). If not specified, order will be ascending.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  orderBy(fieldPath, directionStr) {\n    (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n    directionStr = validateQueryOrder('directionStr', directionStr);\n    if (this._queryOptions.startAt || this._queryOptions.endAt) {\n      throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');\n    }\n    const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n    const options = this._queryOptions.with({\n      fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * first matching documents.\n   *\n   * This function returns a new (immutable) instance of the Query (rather than\n   * modify the existing instance) to impose the limit.\n   *\n   * @param {number} limit The maximum number of items to return.\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  limit(limit) {\n    (0, validate_1.validateInteger)('limit', limit);\n    const options = this._queryOptions.with({\n      limit,\n      limitType: LimitType.First\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that only returns the\n   * last matching documents.\n   *\n   * You must specify at least one orderBy clause for limitToLast queries,\n   * otherwise an exception will be thrown during execution.\n   *\n   * Results for limitToLast queries cannot be streamed via the `stream()` API.\n   *\n   * @param limit The maximum number of items to return.\n   * @return The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limitToLast(1).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  limitToLast(limit) {\n    (0, validate_1.validateInteger)('limitToLast', limit);\n    const options = this._queryOptions.with({\n      limit,\n      limitType: LimitType.Last\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Specifies the offset of the returned results.\n   *\n   * This function returns a new (immutable) instance of the\n   * [Query]{@link Query} (rather than modify the existing instance)\n   * to impose the offset.\n   *\n   * @param {number} offset The offset to apply to the Query results\n   * @returns {Query} The created Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '>', 42);\n   *\n   * query.limit(10).offset(20).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  offset(offset) {\n    (0, validate_1.validateInteger)('offset', offset);\n    const options = this._queryOptions.with({\n      offset\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Returns a query that counts the documents in the result set of this\n   * query.\n   *\n   * The returned query, when executed, counts the documents in the result set\n   * of this query without actually downloading the documents.\n   *\n   * Using the returned query to count the documents is efficient because only\n   * the final count, not the documents' data, is downloaded. The returned\n   * query can count the documents in cases where the result set is\n   * prohibitively large to download entirely (thousands of documents).\n   *\n   * @return a query that counts the documents in the result set of this\n   * query. The count can be retrieved from `snapshot.data().count`, where\n   * `snapshot` is the `AggregateQuerySnapshot` resulting from running the\n   * returned query.\n   */\n  count() {\n    return this.aggregate({\n      count: aggregate_1.AggregateField.count()\n    });\n  }\n  /**\n   * Returns a query that can perform the given aggregations.\n   *\n   * The returned query, when executed, calculates the specified aggregations\n   * over the documents in the result set of this query without actually\n   * downloading the documents.\n   *\n   * Using the returned query to perform aggregations is efficient because only\n   * the final aggregation values, not the documents' data, is downloaded. The\n   * returned query can perform aggregations of the documents count the\n   * documents in cases where the result set is prohibitively large to download\n   * entirely (thousands of documents).\n   *\n   * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n   * to perform over the result set. The AggregateSpec specifies aliases for each\n   * aggregate, which can be used to retrieve the aggregate result.\n   * @example\n   * ```typescript\n   * const aggregateQuery = col.aggregate(query, {\n   *   countOfDocs: count(),\n   *   totalHours: sum('hours'),\n   *   averageScore: average('score')\n   * });\n   *\n   * const aggregateSnapshot = await aggregateQuery.get();\n   * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n   * const totalHours: number = aggregateSnapshot.data().totalHours;\n   * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n   * ```\n   */\n  aggregate(aggregateSpec) {\n    return new AggregateQuery(this, aggregateSpec);\n  }\n  /**\n   * Returns true if this `Query` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `Query` is equal to the provided value.\n   */\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);\n  }\n  /**\n   * Returns the sorted array of inequality filter fields used in this query.\n   *\n   * @return An array of inequality filter fields sorted lexicographically by FieldPath.\n   */\n  getInequalityFilterFields() {\n    const inequalityFields = [];\n    for (const filter of this._queryOptions.filters) {\n      for (const subFilter of filter.getFlattenedFilters()) {\n        if (subFilter.isInequalityFilter()) {\n          inequalityFields.push(subFilter.field);\n        }\n      }\n    }\n    return inequalityFields.sort((a, b) => a.compareTo(b));\n  }\n  /**\n   * Computes the backend ordering semantics for DocumentSnapshot cursors.\n   *\n   * @private\n   * @internal\n   * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n   * set of field values to use as the boundary.\n   * @returns The implicit ordering semantics.\n   */\n  createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n    // Add an implicit orderBy if the only cursor value is a DocumentSnapshot.\n    if (cursorValuesOrDocumentSnapshot.length !== 1 || !(cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot)) {\n      return this._queryOptions.fieldOrders;\n    }\n    const fieldOrders = this._queryOptions.fieldOrders.slice();\n    const fieldsNormalized = new Set([...fieldOrders.map(item => item.field.toString())]);\n    /** The order of the implicit ordering always matches the last explicit order by. */\n    const lastDirection = fieldOrders.length === 0 ? directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;\n    /**\n     * Any inequality fields not explicitly ordered should be implicitly ordered in a\n     * lexicographical order. When there are multiple inequality filters on the same field, the\n     * field should be added only once.\n     * Note: getInequalityFilterFields function sorts the key field before\n     * other fields. However, we want the key field to be sorted last.\n     */\n    const inequalityFields = this.getInequalityFilterFields();\n    for (const field of inequalityFields) {\n      if (!fieldsNormalized.has(field.toString()) && !field.isEqual(path_1.FieldPath.documentId())) {\n        fieldOrders.push(new FieldOrder(field, lastDirection));\n        fieldsNormalized.add(field.toString());\n      }\n    }\n    // Add the document key field to the last if it is not explicitly ordered.\n    if (!fieldsNormalized.has(path_1.FieldPath.documentId().toString())) {\n      fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n    }\n    return fieldOrders;\n  }\n  /**\n   * Builds a Firestore 'Position' proto message.\n   *\n   * @private\n   * @internal\n   * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n   * cursor.\n   * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n   * snapshot of the document or the set of field values to use as the boundary.\n   * @param before Whether the query boundary lies just before or after the\n   * provided data.\n   * @returns {Object} The proto message.\n   */\n  createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n    let fieldValues;\n    if (cursorValuesOrDocumentSnapshot.length === 1 && cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot) {\n      fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n    } else {\n      fieldValues = cursorValuesOrDocumentSnapshot;\n    }\n    if (fieldValues.length > fieldOrders.length) {\n      throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');\n    }\n    const options = {\n      values: [],\n      before\n    };\n    for (let i = 0; i < fieldValues.length; ++i) {\n      let fieldValue = fieldValues[i];\n      if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n        fieldValue = this.validateReference(fieldValue);\n      }\n      validateQueryValue(i, fieldValue, this._allowUndefined);\n      options.values.push(this._serializer.encodeValue(fieldValue));\n    }\n    return options;\n  }\n  /**\n   * Validates that a value used with FieldValue.documentId() is either a\n   * string or a DocumentReference that is part of the query`s result set.\n   * Throws a validation error or returns a DocumentReference that can\n   * directly be used in the Query.\n   *\n   * @param val The value to validate.\n   * @throws If the value cannot be used for this query.\n   * @return If valid, returns a DocumentReference that can be used with the\n   * query.\n   * @private\n   * @internal\n   */\n  validateReference(val) {\n    const basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    let reference;\n    if (typeof val === 'string') {\n      const path = basePath.append(val);\n      if (this._queryOptions.allDescendants) {\n        if (!path.isDocument) {\n          throw new Error('When querying a collection group and ordering by ' + 'FieldPath.documentId(), the corresponding value must result in ' + `a valid document path, but '${val}' is not because it ` + 'contains an odd number of segments.');\n        }\n      } else if (val.indexOf('/') !== -1) {\n        throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' + `the corresponding value must be a plain document ID, but '${val}' ` + 'contains a slash.');\n      }\n      reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n    } else if (val instanceof DocumentReference) {\n      reference = val;\n      if (!basePath.isPrefixOf(reference._path)) {\n        throw new Error(`\"${reference.path}\" is not part of the query result set and ` + 'cannot be used as a query boundary.');\n      }\n    } else {\n      throw new Error('The corresponding value for FieldPath.documentId() must be a ' + `string or a DocumentReference, but was \"${val}\".`);\n    }\n    if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {\n      throw new Error('Only a direct child can be used as a query boundary. ' + `Found: \"${reference.path}\".`);\n    }\n    return reference;\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start at or the field values to\n   * start this query at, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  startAt() {\n    for (var _len2 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      fieldValuesOrDocumentSnapshot[_key2] = arguments[_key2];\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that starts after the\n   * provided set of field values relative to the order of the query. The order\n   * of the provided values must match the order of the order by clauses of the\n   * query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should start after or the field values to\n   * start this query after, in order of the query's order by.\n   * @returns {Query} A query with the new starting point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  startAfter() {\n    for (var _len3 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      fieldValuesOrDocumentSnapshot[_key3] = arguments[_key3];\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      startAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends before the set of\n   * field values relative to the order of the query. The order of the provided\n   * values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end before or the field values to\n   * end this query before, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  endBefore() {\n    for (var _len4 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      fieldValuesOrDocumentSnapshot[_key4] = arguments[_key4];\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Creates and returns a new [Query]{@link Query} that ends at the provided\n   * set of field values relative to the order of the query. The order of the\n   * provided values must match the order of the order by clauses of the query.\n   *\n   * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n   * of the document the query results should end at or the field values to end\n   * this query at, in order of the query's order by.\n   * @returns {Query} A query with the new ending point.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col');\n   *\n   * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  endAt() {\n    for (var _len5 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      fieldValuesOrDocumentSnapshot[_key5] = arguments[_key5];\n    }\n    (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n    const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n    const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n    const options = this._queryOptions.with({\n      fieldOrders,\n      endAt\n    });\n    return new Query(this._firestore, options);\n  }\n  /**\n   * Executes the query and returns the results as a\n   * [QuerySnapshot]{@link QuerySnapshot}.\n   *\n   * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n   * of the Query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.get().then(querySnapshot => {\n   *   querySnapshot.forEach(documentSnapshot => {\n   *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n   *   });\n   * });\n   * ```\n   */\n  get() {\n    return this._get();\n  }\n  /**\n   * Plans and optionally executes this query. Returns a Promise that will be\n   * resolved with the planner information, statistics from the query execution (if any),\n   * and the query results (if any).\n   *\n   * @return A Promise that will be resolved with the planner information, statistics\n   *  from the query execution (if any), and the query results (if any).\n   */\n  explain(options) {\n    if (options === undefined) {\n      options = {};\n    }\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    return new Promise((resolve, reject) => {\n      let readTime;\n      let docs = null;\n      let metrics = null;\n      this._stream(undefined, options).on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      }).on('data', data => {\n        if (data.readTime) {\n          readTime = data.readTime;\n        }\n        if (data.document) {\n          if (docs === null) {\n            docs = [];\n          }\n          docs.push(data.document);\n        }\n        if (data.explainMetrics) {\n          metrics = data.explainMetrics;\n          if (docs === null && (metrics === null || metrics === void 0 ? void 0 : metrics.executionStats) !== null) {\n            // This indicates that the query was executed, but no documents\n            // had matched the query.\n            docs = [];\n          }\n        }\n      }).on('end', () => {\n        if (metrics === null) {\n          reject('No explain results.');\n        }\n        // Some explain queries will not have a snapshot associated with them.\n        let snapshot = null;\n        if (docs !== null) {\n          if (this._queryOptions.limitType === LimitType.Last) {\n            // The results for limitToLast queries need to be flipped since\n            // we reversed the ordering constraints before sending the query\n            // to the backend.\n            docs.reverse();\n          }\n          snapshot = new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n            const changes = [];\n            for (let i = 0; i < docs.length; ++i) {\n              changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n            }\n            return changes;\n          });\n        }\n        resolve(new query_profile_1.ExplainResults(metrics, snapshot));\n      });\n    });\n  }\n  /**\n   * Internal get() method that accepts an optional transaction id.\n   *\n   * @private\n   * @internal\n   * @param transactionIdOrReadTime A transaction ID or the read time at which\n   * to execute the query.\n   */\n  _get(transactionIdOrReadTime) {\n    const docs = [];\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    return new Promise((resolve, reject) => {\n      let readTime;\n      this._stream(transactionIdOrReadTime).on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      }).on('data', result => {\n        readTime = result.readTime;\n        if (result.document) {\n          docs.push(result.document);\n        }\n      }).on('end', () => {\n        if (this._queryOptions.limitType === LimitType.Last) {\n          // The results for limitToLast queries need to be flipped since\n          // we reversed the ordering constraints before sending the query\n          // to the backend.\n          docs.reverse();\n        }\n        resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n          const changes = [];\n          for (let i = 0; i < docs.length; ++i) {\n            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n          }\n          return changes;\n        }));\n      });\n    });\n  }\n  /**\n   * Executes the query and streams the results as\n   * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n   *\n   * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n   * QueryDocumentSnapshots.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.stream().on('data', (documentSnapshot) => {\n   *   console.log(`Found document with name '${documentSnapshot.id}'`);\n   *   ++count;\n   * }).on('end', () => {\n   *   console.log(`Total count is ${count}`);\n   * });\n   * ```\n   */\n  stream() {\n    if (this._queryOptions.limitType === LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');\n    }\n    const responseStream = this._stream();\n    const transform = new stream_1.Transform({\n      objectMode: true,\n      transform(chunk, encoding, callback) {\n        callback(undefined, chunk.document);\n      }\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', e => transform.destroy(e));\n    return transform;\n  }\n  /**\n   * Executes the query and streams the results as the following object:\n   * {document?: DocumentSnapshot, metrics?: ExplainMetrics}\n   *\n   * The stream surfaces documents one at a time as they are received from the\n   * server, and at the end, it will surface the metrics associated with\n   * executing the query.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let count = 0;\n   *\n   * query.explainStream({analyze: true}).on('data', (data) => {\n   *   if (data.document) {\n   *     // Use data.document which is a DocumentSnapshot instance.\n   *     console.log(`Found document with name '${data.document.id}'`);\n   *     ++count;\n   *   }\n   *   if (data.metrics) {\n   *     // Use data.metrics which is an ExplainMetrics instance.\n   *   }\n   * }).on('end', () => {\n   *   console.log(`Received ${count} documents.`);\n   * });\n   * ```\n   */\n  explainStream(explainOptions) {\n    if (explainOptions === undefined) {\n      explainOptions = {};\n    }\n    if (this._queryOptions.limitType === LimitType.Last) {\n      throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.explain() instead.');\n    }\n    const responseStream = this._stream(undefined, explainOptions);\n    const transform = new stream_1.Transform({\n      objectMode: true,\n      transform(chunk, encoding, callback) {\n        callback(undefined, {\n          document: chunk.document,\n          metrics: chunk.explainMetrics\n        });\n      }\n    });\n    responseStream.pipe(transform);\n    responseStream.on('error', e => transform.destroy(e));\n    return transform;\n  }\n  /**\n   * Converts a QueryCursor to its proto representation.\n   *\n   * @param cursor The original cursor value\n   * @private\n   * @internal\n   */\n  toCursor(cursor) {\n    if (cursor) {\n      return cursor.before ? {\n        before: true,\n        values: cursor.values\n      } : {\n        values: cursor.values\n      };\n    }\n    return undefined;\n  }\n  /**\n   * Internal method for serializing a query to its RunQuery proto\n   * representation with an optional transaction id or read time.\n   *\n   * @param transactionIdOrReadTime A transaction ID or the read time at which\n   * to execute the query.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @private\n   * @internal\n   * @returns Serialized JSON for the query.\n   */\n  toProto(transactionIdOrReadTime, explainOptions) {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n    const structuredQuery = this.toStructuredQuery();\n    // For limitToLast queries, the structured query has to be translated to a version with\n    // reversed ordered, and flipped startAt/endAt to work properly.\n    if (this._queryOptions.limitType === LimitType.Last) {\n      if (!this._queryOptions.hasFieldOrders()) {\n        throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n      }\n      structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n        // Flip the orderBy directions since we want the last results\n        const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n        return new FieldOrder(order.field, dir).toProto();\n      });\n      // Swap the cursors to match the now-flipped query ordering.\n      structuredQuery.startAt = this._queryOptions.endAt ? this.toCursor({\n        values: this._queryOptions.endAt.values,\n        before: !this._queryOptions.endAt.before\n      }) : undefined;\n      structuredQuery.endAt = this._queryOptions.startAt ? this.toCursor({\n        values: this._queryOptions.startAt.values,\n        before: !this._queryOptions.startAt.before\n      }) : undefined;\n    }\n    const runQueryRequest = {\n      parent: parentPath.formattedName,\n      structuredQuery\n    };\n    if (transactionIdOrReadTime instanceof Uint8Array) {\n      runQueryRequest.transaction = transactionIdOrReadTime;\n    } else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n      runQueryRequest.readTime = transactionIdOrReadTime.toProto().timestampValue;\n    }\n    if (explainOptions) {\n      runQueryRequest.explainOptions = explainOptions;\n    }\n    return runQueryRequest;\n  }\n  /**\n   * Converts current Query to an IBundledQuery.\n   *\n   * @private\n   * @internal\n   */\n  _toBundledQuery() {\n    const projectId = this.firestore.projectId;\n    const databaseId = this.firestore.databaseId;\n    const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n    const structuredQuery = this.toStructuredQuery();\n    const bundledQuery = {\n      parent: parentPath.formattedName,\n      structuredQuery\n    };\n    if (this._queryOptions.limitType === LimitType.First) {\n      bundledQuery.limitType = 'FIRST';\n    } else if (this._queryOptions.limitType === LimitType.Last) {\n      bundledQuery.limitType = 'LAST';\n    }\n    return bundledQuery;\n  }\n  toStructuredQuery() {\n    const structuredQuery = {\n      from: [{}]\n    };\n    if (this._queryOptions.allDescendants) {\n      structuredQuery.from[0].allDescendants = true;\n    }\n    // Kindless queries select all descendant documents, so we remove the\n    // collectionId field.\n    if (!this._queryOptions.kindless) {\n      structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n    }\n    if (this._queryOptions.filters.length >= 1) {\n      structuredQuery.where = new CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();\n    }\n    if (this._queryOptions.hasFieldOrders()) {\n      structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n    }\n    structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n    structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n    if (this._queryOptions.limit) {\n      structuredQuery.limit = {\n        value: this._queryOptions.limit\n      };\n    }\n    structuredQuery.offset = this._queryOptions.offset;\n    structuredQuery.select = this._queryOptions.projection;\n    return structuredQuery;\n  }\n  /**\n   * @internal\n   * @private\n   * This method exists solely to enable unit tests to mock it.\n   */\n  _isPermanentRpcError(err, methodName) {\n    return (0, util_1.isPermanentRpcError)(err, methodName);\n  }\n  /**\n   * @internal\n   * @private\n   */\n  _hasRetryTimedOut(methodName, startTime) {\n    const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n    if (totalTimeout === 0) {\n      return false;\n    }\n    return Date.now() - startTime >= totalTimeout;\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction ID.\n   *\n   * @param transactionIdOrReadTime A transaction ID or the read time at which\n   * to execute the query.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @private\n   * @internal\n   * @returns A stream of document results.\n   */\n  _stream(transactionIdOrReadTime, explainOptions) {\n    const tag = (0, util_1.requestTag)();\n    const startTime = Date.now();\n    const isExplain = explainOptions !== undefined;\n    let lastReceivedDocument = null;\n    let backendStream;\n    const stream = new stream_1.Transform({\n      objectMode: true,\n      transform: (proto, enc, callback) => {\n        if (proto === NOOP_MESSAGE) {\n          callback(undefined);\n          return;\n        }\n        const output = {};\n        if (proto.readTime) {\n          output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n        }\n        if (proto.document) {\n          const document = this.firestore.snapshot_(proto.document, proto.readTime);\n          const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n          // Recreate the QueryDocumentSnapshot with the DocumentReference\n          // containing the original converter.\n          finalDoc.fieldsProto = document._fieldsProto;\n          finalDoc.readTime = document.readTime;\n          finalDoc.createTime = document.createTime;\n          finalDoc.updateTime = document.updateTime;\n          lastReceivedDocument = finalDoc.build();\n          output.document = lastReceivedDocument;\n        }\n        if (proto.explainMetrics) {\n          output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n        }\n        callback(undefined, output);\n        if (proto.done) {\n          (0, logger_1.logger)('Query._stream', tag, 'Trigger Logical Termination.');\n          backendStream.unpipe(stream);\n          backendStream.resume();\n          backendStream.end();\n          stream.end();\n        }\n      }\n    });\n    this.firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      let request = this.toProto(transactionIdOrReadTime, explainOptions);\n      let streamActive;\n      do {\n        streamActive = new util_1.Deferred();\n        const methodName = 'runQuery';\n        backendStream = await this._firestore.requestStream(methodName, /* bidirectional= */false, request, tag);\n        backendStream.on('error', err => {\n          backendStream.unpipe(stream);\n          // If a non-transactional query failed, attempt to restart.\n          // Transactional queries are retried via the transaction runner.\n          // Explain queries are not retried with a cursor. That would produce\n          // incorrect/partial profiling results.\n          if (!isExplain && !transactionIdOrReadTime && !this._isPermanentRpcError(err, 'runQuery')) {\n            (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error:', err);\n            // Enqueue a \"no-op\" write into the stream and wait for it to be\n            // read by the downstream consumer. This ensures that all enqueued\n            // results in the stream are consumed, which will give us an accurate\n            // value for `lastReceivedDocument`.\n            stream.write(NOOP_MESSAGE, () => {\n              if (this._hasRetryTimedOut(methodName, startTime)) {\n                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                stream.destroy(err);\n                streamActive.resolve( /* active= */false);\n              } else if (lastReceivedDocument) {\n                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' + 'documents, so the stream is being retried.');\n                // Restart the query but use the last document we received as\n                // the query cursor. Note that we do not use backoff here. The\n                // call to `requestStream()` will backoff should the restart\n                // fail before delivering any results.\n                if (this._queryOptions.requireConsistency) {\n                  request = this.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                } else {\n                  request = this.startAfter(lastReceivedDocument).toProto();\n                }\n                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                lastReceivedDocument = null;\n                streamActive.resolve( /* active= */true);\n              } else {\n                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error however no progress was made receiving ' + 'documents, so the stream is being closed.');\n                stream.destroy(err);\n                streamActive.resolve( /* active= */false);\n              }\n            });\n          } else {\n            (0, logger_1.logger)('Query._stream', tag, 'Query failed with stream error:', err);\n            stream.destroy(err);\n            streamActive.resolve( /* active= */false);\n          }\n        });\n        backendStream.on('end', () => {\n          streamActive.resolve( /* active= */false);\n        });\n        backendStream.resume();\n        backendStream.pipe(stream);\n      } while (await streamActive.promise);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n  /**\n   * Attaches a listener for QuerySnapshot events.\n   *\n   * @param {querySnapshotCallback} onNext A callback to be called every time\n   * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n   * @param {errorCallback=} onError A callback to be called if the listen\n   * fails or is cancelled. No further callbacks will occur.\n   *\n   * @returns {function()} An unsubscribe function that can be called to cancel\n   * the snapshot listener.\n   *\n   * @example\n   * ```\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * let unsubscribe = query.onSnapshot(querySnapshot => {\n   *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n   * }, err => {\n   *   console.log(`Encountered error: ${err}`);\n   * });\n   *\n   * // Remove this listener.\n   * unsubscribe();\n   * ```\n   */\n  onSnapshot(onNext, onError) {\n    (0, validate_1.validateFunction)('onNext', onNext);\n    (0, validate_1.validateFunction)('onError', onError, {\n      optional: true\n    });\n    const watch = new (require('./watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);\n    return watch.onSnapshot((readTime, size, docs, changes) => {\n      onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n    }, onError || console.error);\n  }\n  /**\n   * Returns a function that can be used to sort QueryDocumentSnapshots\n   * according to the sort criteria of this query.\n   *\n   * @private\n   * @internal\n   */\n  comparator() {\n    return (doc1, doc2) => {\n      // Add implicit sorting by name, using the last specified direction.\n      const lastDirection = this._queryOptions.hasFieldOrders() ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction : 'ASCENDING';\n      const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n      for (const orderBy of orderBys) {\n        let comp;\n        if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n          comp = doc1.ref._path.compareTo(doc2.ref._path);\n        } else {\n          const v1 = doc1.protoField(orderBy.field);\n          const v2 = doc2.protoField(orderBy.field);\n          if (v1 === undefined || v2 === undefined) {\n            throw new Error('Trying to compare documents on fields that ' + \"don't exist. Please include the fields you are ordering on \" + 'in your select() call.');\n          }\n          comp = (0, order_1.compare)(v1, v2);\n        }\n        if (comp !== 0) {\n          const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n          return direction * comp;\n        }\n      }\n      return 0;\n    };\n  }\n  /**\n   * Applies a custom data converter to this Query, allowing you to use your\n   * own custom model objects with Firestore. When you call get() on the\n   * returned Query, the provided converter will convert between Firestore\n   * data of type `NewDbModelType` and your custom type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A Query that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)()));\n  }\n}\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class CollectionReference\n * @extends Query\n */\nclass CollectionReference extends Query {\n  /**\n   * @private\n   *\n   * @param firestore The Firestore Database client.\n   * @param path The Path of this collection.\n   */\n  constructor(firestore, path, converter) {\n    super(firestore, QueryOptions.forCollectionQuery(path, converter));\n  }\n  /**\n   * Returns a resource path for this collection.\n   * @private\n   * @internal\n   */\n  get _resourcePath() {\n    return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n  }\n  /**\n   * The last path element of the referenced collection.\n   *\n   * @type {string}\n   * @name CollectionReference#id\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`ID of the subcollection: ${collectionRef.id}`);\n   * ```\n   */\n  get id() {\n    return this._queryOptions.collectionId;\n  }\n  /**\n   * A reference to the containing Document if this is a subcollection, else\n   * null.\n   *\n   * @type {DocumentReference|null}\n   * @name CollectionReference#parent\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * let documentRef = collectionRef.parent;\n   * console.log(`Parent name: ${documentRef.path}`);\n   * ```\n   */\n  get parent() {\n    if (this._queryOptions.parentPath.isDocument) {\n      return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n    }\n    return null;\n  }\n  /**\n   * A string representing the path of the referenced collection (relative\n   * to the root of the database).\n   *\n   * @type {string}\n   * @name CollectionReference#path\n   * @readonly\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col/doc/subcollection');\n   * console.log(`Path of the subcollection: ${collectionRef.path}`);\n   * ```\n   */\n  get path() {\n    return this._resourcePath.relativeName;\n  }\n  /**\n   * Retrieves the list of documents in this collection.\n   *\n   * The document references returned may include references to \"missing\n   * documents\", i.e. document locations that have no document present but\n   * which contain subcollections with documents. Attempting to read such a\n   * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n   * `DocumentSnapshot` whose `.exists` property is false.\n   *\n   * @return {Promise<DocumentReference[]>} The list of documents in this\n   * collection.\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   *\n   * return collectionRef.listDocuments().then(documentRefs => {\n   *    return firestore.getAll(...documentRefs);\n   * }).then(documentSnapshots => {\n   *    for (let documentSnapshot of documentSnapshots) {\n   *       if (documentSnapshot.exists) {\n   *         console.log(`Found document with data: ${documentSnapshot.id}`);\n   *       } else {\n   *         console.log(`Found missing document: ${documentSnapshot.id}`);\n   *       }\n   *    }\n   * });\n   * ```\n   */\n  listDocuments() {\n    const tag = (0, util_1.requestTag)();\n    return this.firestore.initializeIfNeeded(tag).then(() => {\n      const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);\n      const request = {\n        parent: parentPath.formattedName,\n        collectionId: this.id,\n        showMissing: true,\n        // Setting `pageSize` to an arbitrarily large value lets the backend cap\n        // the page size (currently to 300). Note that the backend rejects\n        // MAX_INT32 (b/146883794).\n        pageSize: Math.pow(2, 16) - 1,\n        mask: {\n          fieldPaths: []\n        }\n      };\n      return this.firestore.request('listDocuments', request, tag).then(documents => {\n        // Note that the backend already orders these documents by name,\n        // so we do not need to manually sort them.\n        return documents.map(doc => {\n          const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n          return this.doc(path.id);\n        });\n      });\n    });\n  }\n  /**\n   * Gets a [DocumentReference]{@link DocumentReference} instance that\n   * refers to the document at the specified path. If no path is specified, an\n   * automatically-generated unique ID will be used for the returned\n   * DocumentReference.\n   *\n   * @param {string=} documentPath A slash-separated path to a document.\n   * @returns {DocumentReference} The `DocumentReference`\n   * instance.\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   * let documentRefWithName = collectionRef.doc('doc');\n   * let documentRefWithAutoId = collectionRef.doc();\n   * console.log(`Reference with name: ${documentRefWithName.path}`);\n   * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n   * ```\n   */\n  doc(documentPath) {\n    if (arguments.length === 0) {\n      documentPath = (0, util_1.autoId)();\n    } else {\n      (0, path_1.validateResourcePath)('documentPath', documentPath);\n    }\n    const path = this._resourcePath.append(documentPath);\n    if (!path.isDocument) {\n      throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n    }\n    return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n  }\n  /**\n   * Add a new document to this collection with the specified data, assigning\n   * it a document ID automatically.\n   *\n   * @param {DocumentData} data An Object containing the data for the new\n   * document.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {Promise.<DocumentReference>} A Promise resolved with a\n   * [DocumentReference]{@link DocumentReference} pointing to the\n   * newly created document.\n   *\n   * @example\n   * ```\n   * let collectionRef = firestore.collection('col');\n   * collectionRef.add({foo: 'bar'}).then(documentReference => {\n   *   console.log(`Added document with name: ${documentReference.id}`);\n   * });\n   * ```\n   */\n  add(data) {\n    const firestoreData = this._queryOptions.converter.toFirestore(data);\n    (0, write_batch_1.validateDocumentData)('data', firestoreData, /*allowDeletes=*/false, this._allowUndefined);\n    const documentRef = this.doc();\n    return documentRef.create(data).then(() => documentRef);\n  }\n  /**\n   * Returns true if this `CollectionReference` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return {boolean} true if this `CollectionReference` is equal to the\n   * provided value.\n   */\n  isEqual(other) {\n    return this === other || other instanceof CollectionReference && super.isEqual(other);\n  }\n  /**\n   * Applies a custom data converter to this CollectionReference, allowing you\n   * to use your own custom model objects with Firestore. When you call add() on\n   * the returned CollectionReference instance, the provided converter will\n   * convert between Firestore data of type `NewDbModelType` and your custom\n   * type `NewAppModelType`.\n   *\n   * Using the converter allows you to specify generic type arguments when\n   * storing and retrieving objects from Firestore.\n   *\n   * Passing in `null` as the converter parameter removes the current\n   * converter.\n   *\n   * @example\n   * ```\n   * class Post {\n   *   constructor(readonly title: string, readonly author: string) {}\n   *\n   *   toString(): string {\n   *     return this.title + ', by ' + this.author;\n   *   }\n   * }\n   *\n   * const postConverter = {\n   *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n   *     return {title: post.title, author: post.author};\n   *   },\n   *   fromFirestore(\n   *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n   *   ): Post {\n   *     const data = snapshot.data();\n   *     return new Post(data.title, data.author);\n   *   }\n   * };\n   *\n   * const postSnap = await Firestore()\n   *   .collection('posts')\n   *   .withConverter(postConverter)\n   *   .doc().get();\n   * const post = postSnap.data();\n   * if (post !== undefined) {\n   *   post.title; // string\n   *   post.toString(); // Should be defined\n   *   post.someNonExistentProperty; // TS error\n   * }\n   *\n   * ```\n   * @param {FirestoreDataConverter | null} converter Converts objects to and\n   * from Firestore. Passing in `null` removes the current converter.\n   * @return A CollectionReference that uses the provided converter.\n   */\n  withConverter(converter) {\n    return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n  }\n}\nexports.CollectionReference = CollectionReference;\n/**\n * A query that calculates aggregations over an underlying query.\n */\nclass AggregateQuery {\n  /**\n   * @internal\n   * @param _query The query whose aggregations will be calculated by this\n   * object.\n   * @param _aggregates The aggregations that will be performed by this query.\n   */\n  constructor(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _query, _aggregates) {\n    this._query = _query;\n    this._aggregates = _aggregates;\n    this.clientAliasToServerAliasMap = {};\n    this.serverAliasToClientAliasMap = {};\n    // Client-side aliases may be too long and exceed the 1500-byte string size limit.\n    // Such long strings do not need to be transferred over the wire either.\n    // The client maps the user's alias to a short form alias and send that to the server.\n    let aggregationNum = 0;\n    for (const clientAlias in this._aggregates) {\n      if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {\n        const serverAlias = `aggregate_${aggregationNum++}`;\n        this.clientAliasToServerAliasMap[clientAlias] = serverAlias;\n        this.serverAliasToClientAliasMap[serverAlias] = clientAlias;\n      }\n    }\n  }\n  /** The query whose aggregations will be calculated by this object. */\n  get query() {\n    return this._query;\n  }\n  /**\n   * Executes this query.\n   *\n   * @return A promise that will be resolved with the results of the query.\n   */\n  get() {\n    return this._get();\n  }\n  /**\n   * Internal get() method that accepts an optional transaction id.\n   *\n   * @private\n   * @internal\n   * @param {bytes=} transactionId A transaction ID.\n   */\n  _get(transactionIdOrReadTime) {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    let result = null;\n    return new Promise((resolve, reject) => {\n      const stream = this._stream(transactionIdOrReadTime);\n      stream.on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      });\n      stream.on('data', data => {\n        if (data.aggregationResult) {\n          result = data.aggregationResult;\n        }\n      });\n      stream.on('end', () => {\n        stream.destroy();\n        if (result === null) {\n          reject(Error('RunAggregationQueryResponse is missing result'));\n        }\n        resolve(result);\n      });\n    });\n  }\n  /**\n   * Internal streaming method that accepts an optional transaction ID.\n   *\n   * @private\n   * @internal\n   * @param transactionIdOrReadTime A transaction ID or the read time at which\n   * to execute the query.\n   * @param explainOptions Options to use for explaining the query (if any).\n   * @returns A stream of document results.\n   */\n  _stream(transactionIdOrReadTime, explainOptions) {\n    const tag = (0, util_1.requestTag)();\n    const firestore = this._query.firestore;\n    const stream = new stream_1.Transform({\n      objectMode: true,\n      transform: (proto, enc, callback) => {\n        const output = {};\n        if (proto.result) {\n          const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n          const data = this.decodeResult(proto.result);\n          output.aggregationResult = new AggregateQuerySnapshot(this, readTime, data);\n        }\n        if (proto.explainMetrics) {\n          output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);\n        }\n        callback(undefined, output);\n      }\n    });\n    firestore.initializeIfNeeded(tag).then(async () => {\n      // `toProto()` might throw an exception. We rely on the behavior of an\n      // async function to convert this exception into the rejected Promise we\n      // catch below.\n      const request = this.toProto(transactionIdOrReadTime, explainOptions);\n      const backendStream = await firestore.requestStream('runAggregationQuery', /* bidirectional= */false, request, tag);\n      stream.on('close', () => {\n        backendStream.resume();\n        backendStream.end();\n      });\n      backendStream.on('error', err => {\n        // TODO(group-by) When group-by queries are supported for aggregates\n        // consider implementing retries if the stream is making progress\n        // receiving results for groups. See the use of lastReceivedDocument\n        // in the retry strategy for runQuery.\n        // Also note that explain queries should not be retried.\n        backendStream.unpipe(stream);\n        (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);\n        stream.destroy(err);\n      });\n      backendStream.resume();\n      backendStream.pipe(stream);\n    }).catch(e => stream.destroy(e));\n    return stream;\n  }\n  /**\n   * Internal method to decode values within result.\n   * @private\n   */\n  decodeResult(proto) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const data = {};\n    const fields = proto.aggregateFields;\n    if (fields) {\n      const serializer = this._query.firestore._serializer;\n      for (const prop of Object.keys(fields)) {\n        const alias = this.serverAliasToClientAliasMap[prop];\n        assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);\n        if (this._aggregates[alias] === undefined) {\n          throw new Error(`Unexpected alias [${prop}] in result aggregate result`);\n        }\n        data[alias] = serializer.decodeValue(fields[prop]);\n      }\n    }\n    return data;\n  }\n  /**\n   * Internal method for serializing a query to its RunAggregationQuery proto\n   * representation with an optional transaction id.\n   *\n   * @private\n   * @internal\n   * @returns Serialized JSON for the query.\n   */\n  toProto(transactionIdOrReadTime, explainOptions) {\n    const queryProto = this._query.toProto();\n    const runQueryRequest = {\n      parent: queryProto.parent,\n      structuredAggregationQuery: {\n        structuredQuery: queryProto.structuredQuery,\n        aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias) => {\n          const serverAlias = this.clientAliasToServerAliasMap[clientAlias];\n          assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);\n          return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();\n        })\n      }\n    };\n    if (transactionIdOrReadTime instanceof Uint8Array) {\n      runQueryRequest.transaction = transactionIdOrReadTime;\n    } else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n      runQueryRequest.readTime = transactionIdOrReadTime;\n    }\n    if (explainOptions) {\n      runQueryRequest.explainOptions = explainOptions;\n    }\n    return runQueryRequest;\n  }\n  /**\n   * Compares this object with the given object for equality.\n   *\n   * This object is considered \"equal\" to the other object if and only if\n   * `other` performs the same aggregations as this `AggregateQuery` and\n   * the underlying Query of `other` compares equal to that of this object\n   * using `Query.isEqual()`.\n   *\n   * @param other The object to compare to this object for equality.\n   * @return `true` if this object is \"equal\" to the given object, as\n   * defined above, or `false` otherwise.\n   */\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof AggregateQuery)) {\n      return false;\n    }\n    if (!this.query.isEqual(other.query)) {\n      return false;\n    }\n    return deepEqual(this._aggregates, other._aggregates);\n  }\n  /**\n   * Plans and optionally executes this query. Returns a Promise that will be\n   * resolved with the planner information, statistics from the query\n   * execution (if any), and the query results (if any).\n   *\n   * @return A Promise that will be resolved with the planner information,\n   * statistics from the query execution (if any), and the query results (if any).\n   */\n  explain(options) {\n    if (options === undefined) {\n      options = {};\n    }\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    let metrics = null;\n    let aggregationResult = null;\n    return new Promise((resolve, reject) => {\n      const stream = this._stream(undefined, options);\n      stream.on('error', err => {\n        reject((0, util_1.wrapError)(err, stack));\n      });\n      stream.on('data', data => {\n        if (data.aggregationResult) {\n          aggregationResult = data.aggregationResult;\n        }\n        if (data.explainMetrics) {\n          metrics = data.explainMetrics;\n        }\n      });\n      stream.on('end', () => {\n        stream.destroy();\n        if (metrics === null) {\n          reject('No explain results.');\n        }\n        resolve(new query_profile_1.ExplainResults(metrics, aggregationResult));\n      });\n    });\n  }\n}\nexports.AggregateQuery = AggregateQuery;\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n  /**\n   * @internal\n   *\n   * @param _query The query that was executed to produce this result.\n   * @param _readTime The time this snapshot was read.\n   * @param _data The results of the aggregations performed over the underlying\n   * query.\n   */\n  constructor(_query, _readTime, _data) {\n    this._query = _query;\n    this._readTime = _readTime;\n    this._data = _data;\n  }\n  /** The query that was executed to produce this result. */\n  get query() {\n    return this._query;\n  }\n  /** The time this snapshot was read. */\n  get readTime() {\n    return this._readTime;\n  }\n  /**\n   * Returns the results of the aggregations performed over the underlying\n   * query.\n   *\n   * The keys of the returned object will be the same as those of the\n   * `AggregateSpec` object specified to the aggregation method, and the\n   * values will be the corresponding aggregation result.\n   *\n   * @returns The results of the aggregations performed over the underlying\n   * query.\n   */\n  data() {\n    return this._data;\n  }\n  /**\n   * Compares this object with the given object for equality.\n   *\n   * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they\n   * have the same data and their underlying queries compare \"equal\" using\n   * `AggregateQuery.isEqual()`.\n   *\n   * @param other The object to compare to this object for equality.\n   * @return `true` if this object is \"equal\" to the given object, as\n   * defined above, or `false` otherwise.\n   */\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof AggregateQuerySnapshot)) {\n      return false;\n    }\n    // Since the read time is different on every read, we explicitly ignore all\n    // document metadata in this comparison, just like\n    // `DocumentSnapshot.isEqual()` does.\n    if (!this.query.isEqual(other.query)) {\n      return false;\n    }\n    return deepEqual(this._data, other._data);\n  }\n}\nexports.AggregateQuerySnapshot = AggregateQuerySnapshot;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOrder(arg, op) {\n  // For backwards compatibility, we support both lower and uppercase values.\n  op = typeof op === 'string' ? op.toLowerCase() : op;\n  (0, validate_1.validateEnumValue)(arg, op, Object.keys(directionOperators), {\n    optional: true\n  });\n  return op;\n}\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOperator(arg, op, fieldValue) {\n  // For backwards compatibility, we support both `=` and `==` for \"equals\".\n  if (op === '=') {\n    op = '==';\n  }\n  (0, validate_1.validateEnumValue)(arg, op, Object.keys(comparisonOperators));\n  if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==' && op !== '!=') {\n    throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on NaN.\");\n  }\n  if (fieldValue === null && op !== '==' && op !== '!=') {\n    throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on Null.\");\n  }\n  return op;\n}\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @return the DocumentReference if valid\n */\nfunction validateDocumentReference(arg, value) {\n  if (!(value instanceof DocumentReference)) {\n    throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentReference'));\n  }\n  return value;\n}\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\nfunction validateQueryValue(arg, value, allowUndefined) {\n  (0, serializer_1.validateUserInput)(arg, value, 'query constraint', {\n    allowDeletes: 'none',\n    allowTransforms: false,\n    allowUndefined\n  });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @internal\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\nfunction isArrayEqual(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n  for (let i = 0; i < left.length; ++i) {\n    if (!left[i].isEqual(right[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n * @internal\n */\nfunction coalesce() {\n  for (var _len6 = arguments.length, values = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    values[_key6] = arguments[_key6];\n  }\n  return values.find(value => value !== undefined);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","validateDocumentReference","validateQueryOperator","validateQueryOrder","AggregateQuerySnapshot","AggregateQuery","CollectionReference","Query","QueryOptions","QuerySnapshot","FieldOrder","DocumentReference","assert","require","stream_1","deepEqual","document_1","document_change_1","logger_1","order_1","path_1","serializer_1","timestamp_1","types_1","util_1","validate_1","write_batch_1","filter_1","aggregate_1","query_profile_1","directionOperators","asc","desc","comparisonOperators","in","NOOP_MESSAGE","Symbol","constructor","_firestore","_path","_converter","arguments","length","undefined","defaultConverter","formattedName","projectId","firestore","databaseId","toQualifiedResourcePath","path","relativeName","id","_resourcePath","parent","get","getAll","then","_ref","result","collection","collectionPath","validateResourcePath","append","isCollection","Error","listCollections","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","create","data","writeBatch","WriteBatch","commit","_ref2","writeResult","delete","precondition","_ref3","set","options","_ref4","update","dataOrField","_len","preconditionOrValues","Array","_key","validateMinNumberOfArguments","_ref5","onSnapshot","onNext","onError","validateFunction","optional","watch","DocumentWatch","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","isEqual","other","toProto","referenceValue","withConverter","converter","field","direction","fieldPath","FilterInternal","CompositeFilterInternal","filters","operator","memoizedFlattenedFilters","getFilters","isConjunction","getFlattenedFilters","reduce","allFilters","subfilter","concat","proto","compositeFilter","op","map","filter","otherFilters","every","index","FieldFilterInternal","serializer","isInequalityFilter","isNaN","unaryFilter","fieldFilter","encodeValue","_query","_readTime","_size","changes","_materializedDocs","_materializedChanges","_docs","_changes","query","empty","docChanges","forEach","callback","thisArg","doc","call","isArrayEqual","LimitType","parentPath","allDescendants","fieldOrders","startAt","endAt","limit","limitType","offset","projection","kindless","requireConsistency","forCollectionGroupQuery","ResourcePath","EMPTY","forCollectionQuery","collectionRef","forKindlessAllDescendants","with","settings","coalesce","hasFieldOrders","filtersEqual","i","_queryOptions","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","_extractFieldValues","documentSnapshot","fieldValues","fieldOrder","FieldPath","documentId","fieldValue","where","fieldPathOrFilter","opStr","Filter","parsedFilter","_parseFilter","UnaryFilter","_parseFieldFilter","_parseCompositeFilter","fieldFilterData","_getValue","_getOperator","_getField","validateFieldPath","validateQueryValue","fromArgument","isArray","el","validateReference","compositeFilterData","parsedFilters","_getFilters","select","fields","orderBy","directionStr","newOrder","validateInteger","First","limitToLast","Last","count","aggregate","AggregateField","aggregateSpec","getInequalityFilterFields","inequalityFields","subFilter","a","b","compareTo","createImplicitOrderBy","cursorValuesOrDocumentSnapshot","DocumentSnapshot","slice","fieldsNormalized","Set","item","toString","lastDirection","ASC","has","add","createCursor","before","values","val","basePath","reference","isDocument","indexOf","isPrefixOf","_len2","fieldValuesOrDocumentSnapshot","_key2","startAfter","_len3","_key3","endBefore","_len4","_key4","_len5","_key5","_get","explain","stack","Promise","resolve","reject","metrics","_stream","on","err","wrapError","explainMetrics","executionStats","snapshot","reverse","DocumentChange","ExplainResults","transactionIdOrReadTime","stream","responseStream","transform","Transform","objectMode","chunk","encoding","pipe","e","destroy","explainStream","explainOptions","toCursor","cursor","structuredQuery","toStructuredQuery","order","dir","runQueryRequest","Uint8Array","transaction","Timestamp","timestampValue","_toBundledQuery","bundledQuery","from","o","_isPermanentRpcError","methodName","isPermanentRpcError","_hasRetryTimedOut","startTime","totalTimeout","getTotalTimeout","Date","now","isExplain","lastReceivedDocument","backendStream","enc","output","fromProto","snapshot_","finalDoc","fieldsProto","_fieldsProto","createTime","updateTime","ExplainMetrics","_fromProto","done","logger","unpipe","resume","end","streamActive","Deferred","requestStream","write","promise","catch","QueryWatch","comparator","doc1","doc2","orderBys","comp","v1","protoField","v2","compare","listDocuments","showMissing","mask","fieldPaths","documents","QualifiedResourcePath","fromSlashSeparatedString","name","documentPath","autoId","firestoreData","toFirestore","validateDocumentData","documentRef","_aggregates","clientAliasToServerAliasMap","serverAliasToClientAliasMap","aggregationNum","clientAlias","prototype","hasOwnProperty","serverAlias","aggregationResult","decodeResult","aggregateFields","prop","keys","alias","decodeValue","queryProto","structuredAggregationQuery","aggregations","mapToArray","Aggregate","aggregateType","_field","_data","arg","toLowerCase","validateEnumValue","invalidArgumentMessage","allowUndefined","validateUserInput","allowDeletes","allowTransforms","left","right","_len6","_key6","find"],"sources":["D:/html/Legacy/node_modules/@google-cloud/firestore/build/src/reference.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateDocumentReference = exports.validateQueryOperator = exports.validateQueryOrder = exports.AggregateQuerySnapshot = exports.AggregateQuery = exports.CollectionReference = exports.Query = exports.QueryOptions = exports.QuerySnapshot = exports.FieldOrder = exports.DocumentReference = void 0;\nconst assert = require(\"assert\");\nconst stream_1 = require(\"stream\");\nconst deepEqual = require(\"fast-deep-equal\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst order_1 = require(\"./order\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst write_batch_1 = require(\"./write-batch\");\nconst filter_1 = require(\"./filter\");\nconst aggregate_1 = require(\"./aggregate\");\nconst query_profile_1 = require(\"./query-profile\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n * @internal\n */\nconst directionOperators = {\n    asc: 'ASCENDING',\n    desc: 'DESCENDING',\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',\n * and 'array-contains-any'.\n *\n * @private\n * @internal\n */\nconst comparisonOperators = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    '!=': 'NOT_EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    'array-contains': 'ARRAY_CONTAINS',\n    in: 'IN',\n    'not-in': 'NOT_IN',\n    'array-contains-any': 'ARRAY_CONTAINS_ANY',\n};\nconst NOOP_MESSAGE = Symbol('a noop message');\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n    /**\n     * @private\n     * @internal\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     * @param _converter The converter to use when serializing data.\n     */\n    constructor(_firestore, \n    /**\n     * @private\n     * @internal\n     **/\n    _path, \n    /**\n     * @internal\n     * @private\n     **/\n    _converter = (0, types_1.defaultConverter)()) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @internal\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        return this._path.toQualifiedResourcePath(projectId, databaseId)\n            .formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     * ```\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     * ```\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     * ```\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * Returns a resource path for this document.\n     * @private\n     * @internal\n     */\n    get _resourcePath() {\n        return this._path;\n    }\n    /**\n     * A reference to the collection to which this DocumentReference belongs.\n     *\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     * ```\n     */\n    get parent() {\n        return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     * ```\n     */\n    get() {\n        return this._firestore.getAll(this).then(([result]) => result);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     * ```\n     */\n    collection(collectionPath) {\n        (0, path_1.validateResourcePath)('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     * ```\n     */\n    listCollections() {\n        const tag = (0, util_1.requestTag)();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const request = {\n                parent: this.formattedName,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n            };\n            return this._firestore\n                .request('listCollectionIds', request, tag)\n                .then(collectionIds => {\n                const collections = [];\n                // We can just sort this list using the default comparator since it\n                // will only contain collection ids.\n                collectionIds.sort();\n                for (const collectionId of collectionIds) {\n                    collections.push(this.collection(collectionId));\n                }\n                return collections;\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @throws {Error} If the provided input is not a valid Firestore document or if the document already exists.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     * ```\n     */\n    create(data) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .create(this, data)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     * ```\n     */\n    delete(precondition) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .delete(this, precondition)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T|Partial<AppModelType>} data A map of the fields and values for\n     * the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * If your input sets any field to an empty map, all nested fields are\n     * overwritten.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched. If your input sets any field to\n     * an empty map, all nested fields are overwritten.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    set(data, options) {\n        let writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        if (options) {\n            writeBatch = writeBatch.set(this, data, options);\n        }\n        else {\n            writeBatch = writeBatch.set(this, data);\n        }\n        return writeBatch.commit().then(([writeResult]) => writeResult);\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @throws {Error} If the provided input is not valid Firestore data.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     * ```\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMinNumberOfArguments)('DocumentReference.update', arguments, 1);\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .update(this, dataOrField, ...preconditionOrValues)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     * ```\n     */\n    onSnapshot(onNext, onError) {\n        (0, validate_1.validateFunction)('onNext', onNext);\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\n        const watch = new (require('./watch').DocumentWatch)(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     * @internal\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    /**\n     * Applies a custom data converter to this DocumentReference, allowing you to\n     * use your own custom model objects with Firestore. When you call set(),\n     * get(), etc. on the returned DocumentReference instance, the provided\n     * converter will convert between Firestore data of type `NewDbModelType` and\n     * your custom type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A DocumentReference that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n    }\n}\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @internal\n * @class\n */\nclass FieldOrder {\n    /**\n     * @param field The name of a document field (member) on which to order query\n     * results.\n     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n     * set the ordering direction to ascending or descending, respectively.\n     */\n    constructor(field, direction = 'ASCENDING') {\n        this.field = field;\n        this.direction = direction;\n    }\n    /**\n     * Generates the proto representation for this field order.\n     * @private\n     * @internal\n     */\n    toProto() {\n        return {\n            field: {\n                fieldPath: this.field.formattedName,\n            },\n            direction: this.direction,\n        };\n    }\n}\nexports.FieldOrder = FieldOrder;\nclass FilterInternal {\n}\nclass CompositeFilterInternal extends FilterInternal {\n    constructor(filters, operator) {\n        super();\n        this.filters = filters;\n        this.operator = operator;\n        // Memoized list of all field filters that can be found by traversing the tree of filters\n        // contained in this composite filter.\n        this.memoizedFlattenedFilters = null;\n    }\n    getFilters() {\n        return this.filters;\n    }\n    isConjunction() {\n        return this.operator === 'AND';\n    }\n    getFlattenedFilters() {\n        if (this.memoizedFlattenedFilters !== null) {\n            return this.memoizedFlattenedFilters;\n        }\n        this.memoizedFlattenedFilters = this.filters.reduce((allFilters, subfilter) => allFilters.concat(subfilter.getFlattenedFilters()), []);\n        return this.memoizedFlattenedFilters;\n    }\n    toProto() {\n        if (this.filters.length === 1) {\n            return this.filters[0].toProto();\n        }\n        const proto = {\n            compositeFilter: {\n                op: this.operator,\n                filters: this.filters.map(filter => filter.toProto()),\n            },\n        };\n        return proto;\n    }\n    isEqual(other) {\n        if (other instanceof CompositeFilterInternal) {\n            const otherFilters = other.getFilters();\n            return (this.operator === other.operator &&\n                this.getFilters().length === other.getFilters().length &&\n                this.getFilters().every((filter, index) => filter.isEqual(otherFilters[index])));\n        }\n        else {\n            return false;\n        }\n    }\n}\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @internal\n * @class\n */\nclass FieldFilterInternal extends FilterInternal {\n    getFlattenedFilters() {\n        return [this];\n    }\n    getFilters() {\n        return [this];\n    }\n    /**\n     * @param serializer The Firestore serializer\n     * @param field The path of the property value to compare.\n     * @param op A comparison operation.\n     * @param value The value to which to compare the field for inclusion in a\n     * query.\n     */\n    constructor(serializer, field, op, value) {\n        super();\n        this.serializer = serializer;\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Returns whether this FieldFilter uses an equals comparison.\n     *\n     * @private\n     * @internal\n     */\n    isInequalityFilter() {\n        switch (this.op) {\n            case 'GREATER_THAN':\n            case 'GREATER_THAN_OR_EQUAL':\n            case 'LESS_THAN':\n            case 'LESS_THAN_OR_EQUAL':\n            case 'NOT_EQUAL':\n            case 'NOT_IN':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Generates the proto representation for this field filter.\n     *\n     * @private\n     * @internal\n     */\n    toProto() {\n        if (typeof this.value === 'number' && isNaN(this.value)) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN',\n                },\n            };\n        }\n        if (this.value === null) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL',\n                },\n            };\n        }\n        return {\n            fieldFilter: {\n                field: {\n                    fieldPath: this.field.formattedName,\n                },\n                op: this.op,\n                value: this.serializer.encodeValue(this.value),\n            },\n        };\n    }\n    isEqual(other) {\n        return (other instanceof FieldFilterInternal &&\n            this.field.isEqual(other.field) &&\n            this.op === other.op &&\n            deepEqual(this.value, other.value));\n    }\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n    /**\n     * @private\n     *\n     * @param _query The originating query.\n     * @param _readTime The time when this query snapshot was obtained.\n     * @param _size The number of documents in the result set.\n     * @param docs A callback returning a sorted array of documents matching\n     * this query\n     * @param changes A callback returning a sorted array of document change\n     * events for this snapshot.\n     */\n    constructor(_query, _readTime, _size, docs, changes) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._size = _size;\n        this._materializedDocs = null;\n        this._materializedChanges = null;\n        this._docs = null;\n        this._changes = null;\n        this._docs = docs;\n        this._changes = changes;\n    }\n    /**\n     * The query on which you called get() or onSnapshot() in order to get this\n     * QuerySnapshot.\n     *\n     * @type {Query}\n     * @name QuerySnapshot#query\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.limit(10).get().then(querySnapshot => {\n     *   console.log(`Returned first batch of results`);\n     *   let query = querySnapshot.query;\n     *   return query.offset(10).get();\n     * }).then(() => {\n     *   console.log(`Returned second batch of results`);\n     * });\n     * ```\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     * ```\n     */\n    get docs() {\n        if (this._materializedDocs) {\n            return this._materializedDocs;\n        }\n        this._materializedDocs = this._docs();\n        this._docs = null;\n        return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     * ```\n     */\n    get empty() {\n        return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     * ```\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     * ```\n     */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     * ```\n     */\n    docChanges() {\n        if (this._materializedChanges) {\n            return this._materializedChanges;\n        }\n        this._materializedChanges = this._changes();\n        this._changes = null;\n        return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    forEach(callback, thisArg) {\n        (0, validate_1.validateFunction)('callback', callback);\n        for (const doc of this.docs) {\n            callback.call(thisArg, doc);\n        }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every query read, we explicitly\n        // ignore all metadata in this comparison.\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof QuerySnapshot)) {\n            return false;\n        }\n        if (this._size !== other._size) {\n            return false;\n        }\n        if (!this._query.isEqual(other._query)) {\n            return false;\n        }\n        if (this._materializedDocs && !this._materializedChanges) {\n            // If we have only materialized the documents, we compare them first.\n            return (isArrayEqual(this.docs, other.docs) &&\n                isArrayEqual(this.docChanges(), other.docChanges()));\n        }\n        // Otherwise, we compare the changes first as we expect there to be fewer.\n        return (isArrayEqual(this.docChanges(), other.docChanges()) &&\n            isArrayEqual(this.docs, other.docs));\n    }\n}\nexports.QuerySnapshot = QuerySnapshot;\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\nvar LimitType;\n(function (LimitType) {\n    LimitType[LimitType[\"First\"] = 0] = \"First\";\n    LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n * @internal\n */\nclass QueryOptions {\n    constructor(parentPath, collectionId, converter, allDescendants, filters, fieldOrders, startAt, endAt, limit, limitType, offset, projection, \n    // Whether to select all documents under `parentPath`. By default, only\n    // collections that match `collectionId` are selected.\n    kindless = false, \n    // Whether to require consistent documents when restarting the query. By\n    // default, restarting the query uses the readTime offset of the original\n    // query to provide consistent results.\n    requireConsistency = true) {\n        this.parentPath = parentPath;\n        this.collectionId = collectionId;\n        this.converter = converter;\n        this.allDescendants = allDescendants;\n        this.filters = filters;\n        this.fieldOrders = fieldOrders;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.offset = offset;\n        this.projection = projection;\n        this.kindless = kindless;\n        this.requireConsistency = requireConsistency;\n    }\n    /**\n     * Returns query options for a collection group query.\n     * @private\n     * @internal\n     */\n    static forCollectionGroupQuery(collectionId, converter = (0, types_1.defaultConverter)()) {\n        return new QueryOptions(\n        /*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a single-collection query.\n     * @private\n     * @internal\n     */\n    static forCollectionQuery(collectionRef, converter = (0, types_1.defaultConverter)()) {\n        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, \n        /*allDescendants=*/ false, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a query that fetches all descendants under the\n     * specified reference.\n     *\n     * @private\n     * @internal\n     */\n    static forKindlessAllDescendants(parent, id, requireConsistency = true) {\n        let options = new QueryOptions(parent, id, (0, types_1.defaultConverter)(), \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n        options = options.with({\n            kindless: true,\n            requireConsistency,\n        });\n        return options;\n    }\n    /**\n     * Returns the union of the current and the provided options.\n     * @private\n     * @internal\n     */\n    with(settings) {\n        return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.filters, this.filters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection), coalesce(settings.kindless, this.kindless), coalesce(settings.requireConsistency, this.requireConsistency));\n    }\n    withConverter(converter) {\n        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.filters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n    }\n    hasFieldOrders() {\n        return this.fieldOrders.length > 0;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof QueryOptions &&\n            this.parentPath.isEqual(other.parentPath) &&\n            this.filtersEqual(other.filters) &&\n            this.collectionId === other.collectionId &&\n            this.converter === other.converter &&\n            this.allDescendants === other.allDescendants &&\n            this.limit === other.limit &&\n            this.offset === other.offset &&\n            deepEqual(this.fieldOrders, other.fieldOrders) &&\n            deepEqual(this.startAt, other.startAt) &&\n            deepEqual(this.endAt, other.endAt) &&\n            deepEqual(this.projection, other.projection) &&\n            this.kindless === other.kindless &&\n            this.requireConsistency === other.requireConsistency);\n    }\n    filtersEqual(other) {\n        if (this.filters.length !== other.length) {\n            return false;\n        }\n        for (let i = 0; i < other.length; i++) {\n            if (!this.filters[i].isEqual(other[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n    /**\n     * @internal\n     * @private\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _queryOptions Options that define the query.\n     */\n    constructor(\n    /**\n     * @internal\n     * @private\n     **/\n    _firestore, \n    /**\n     * @internal\n     * @private\n     **/\n    _queryOptions) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = new serializer_1.Serializer(_firestore);\n        this._allowUndefined =\n            !!this._firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * Extracts field values from the DocumentSnapshot based on the provided\n     * field order.\n     *\n     * @private\n     * @internal\n     * @param documentSnapshot The document to extract the fields from.\n     * @param fieldOrders The field order that defines what fields we should\n     * extract.\n     * @return {Array.<*>} The field values to use.\n     */\n    static _extractFieldValues(documentSnapshot, fieldOrders) {\n        const fieldValues = [];\n        for (const fieldOrder of fieldOrders) {\n            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                fieldValues.push(documentSnapshot.ref);\n            }\n            else {\n                const fieldValue = documentSnapshot.get(fieldOrder.field);\n                if (fieldValue === undefined) {\n                    throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` +\n                        'Please provide a document that contains values for all specified ' +\n                        'orderBy() and where() constraints.');\n                }\n                else {\n                    fieldValues.push(fieldValue);\n                }\n            }\n        }\n        return fieldValues;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     * ```\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    where(fieldPathOrFilter, opStr, value) {\n        let filter;\n        if (fieldPathOrFilter instanceof filter_1.Filter) {\n            filter = fieldPathOrFilter;\n        }\n        else {\n            filter = filter_1.Filter.where(fieldPathOrFilter, opStr, value);\n        }\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify a where() filter after calling startAt(), ' +\n                'startAfter(), endBefore() or endAt().');\n        }\n        const parsedFilter = this._parseFilter(filter);\n        if (parsedFilter.getFilters().length === 0) {\n            // Return the existing query if not adding any more filters (e.g. an empty composite filter).\n            return this;\n        }\n        const options = this._queryOptions.with({\n            filters: this._queryOptions.filters.concat(parsedFilter),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseFilter(filter) {\n        if (filter instanceof filter_1.UnaryFilter) {\n            return this._parseFieldFilter(filter);\n        }\n        return this._parseCompositeFilter(filter);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseFieldFilter(fieldFilterData) {\n        let value = fieldFilterData._getValue();\n        let operator = fieldFilterData._getOperator();\n        const fieldPath = fieldFilterData._getField();\n        (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n        operator = validateQueryOperator('opStr', operator, value);\n        validateQueryValue('value', value, this._allowUndefined);\n        const path = path_1.FieldPath.fromArgument(fieldPath);\n        if (path_1.FieldPath.documentId().isEqual(path)) {\n            if (operator === 'array-contains' || operator === 'array-contains-any') {\n                throw new Error(`Invalid Query. You can't perform '${operator}' ` +\n                    'queries on FieldPath.documentId().');\n            }\n            else if (operator === 'in' || operator === 'not-in') {\n                if (!Array.isArray(value) || value.length === 0) {\n                    throw new Error(`Invalid Query. A non-empty array is required for '${operator}' filters.`);\n                }\n                value = value.map(el => this.validateReference(el));\n            }\n            else {\n                value = this.validateReference(value);\n            }\n        }\n        return new FieldFilterInternal(this._serializer, path, comparisonOperators[operator], value);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _parseCompositeFilter(compositeFilterData) {\n        const parsedFilters = compositeFilterData\n            ._getFilters()\n            .map(filter => this._parseFilter(filter))\n            .filter(parsedFilter => parsedFilter.getFilters().length > 0);\n        // For composite filters containing 1 filter, return the only filter.\n        // For example: AND(FieldFilter1) == FieldFilter1\n        if (parsedFilters.length === 1) {\n            return parsedFilters[0];\n        }\n        return new CompositeFilterInternal(parsedFilters, compositeFilterData._getOperator() === 'AND' ? 'AND' : 'OR');\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * Queries that contain field masks cannot be listened to via `onSnapshot()`\n     * listeners.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     * ```\n     */\n    select(...fieldPaths) {\n        const fields = [];\n        if (fieldPaths.length === 0) {\n            fields.push({ fieldPath: path_1.FieldPath.documentId().formattedName });\n        }\n        else {\n            for (let i = 0; i < fieldPaths.length; ++i) {\n                (0, path_1.validateFieldPath)(i, fieldPaths[i]);\n                fields.push({\n                    fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,\n                });\n            }\n        }\n        // By specifying a field mask, the query result no longer conforms to type\n        // `T`. We there return `Query<DocumentData>`;\n        const options = this._queryOptions.with({\n            projection: { fields },\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    orderBy(fieldPath, directionStr) {\n        (0, path_1.validateFieldPath)('fieldPath', fieldPath);\n        directionStr = validateQueryOrder('directionStr', directionStr);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify an orderBy() constraint after calling ' +\n                'startAt(), startAfter(), endBefore() or endAt().');\n        }\n        const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n        const options = this._queryOptions.with({\n            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    limit(limit) {\n        (0, validate_1.validateInteger)('limit', limit);\n        const options = this._queryOptions.with({\n            limit,\n            limitType: LimitType.First,\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    limitToLast(limit) {\n        (0, validate_1.validateInteger)('limitToLast', limit);\n        const options = this._queryOptions.with({ limit, limitType: LimitType.Last });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    offset(offset) {\n        (0, validate_1.validateInteger)('offset', offset);\n        const options = this._queryOptions.with({ offset });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Returns a query that counts the documents in the result set of this\n     * query.\n     *\n     * The returned query, when executed, counts the documents in the result set\n     * of this query without actually downloading the documents.\n     *\n     * Using the returned query to count the documents is efficient because only\n     * the final count, not the documents' data, is downloaded. The returned\n     * query can count the documents in cases where the result set is\n     * prohibitively large to download entirely (thousands of documents).\n     *\n     * @return a query that counts the documents in the result set of this\n     * query. The count can be retrieved from `snapshot.data().count`, where\n     * `snapshot` is the `AggregateQuerySnapshot` resulting from running the\n     * returned query.\n     */\n    count() {\n        return this.aggregate({\n            count: aggregate_1.AggregateField.count(),\n        });\n    }\n    /**\n     * Returns a query that can perform the given aggregations.\n     *\n     * The returned query, when executed, calculates the specified aggregations\n     * over the documents in the result set of this query without actually\n     * downloading the documents.\n     *\n     * Using the returned query to perform aggregations is efficient because only\n     * the final aggregation values, not the documents' data, is downloaded. The\n     * returned query can perform aggregations of the documents count the\n     * documents in cases where the result set is prohibitively large to download\n     * entirely (thousands of documents).\n     *\n     * @param aggregateSpec An `AggregateSpec` object that specifies the aggregates\n     * to perform over the result set. The AggregateSpec specifies aliases for each\n     * aggregate, which can be used to retrieve the aggregate result.\n     * @example\n     * ```typescript\n     * const aggregateQuery = col.aggregate(query, {\n     *   countOfDocs: count(),\n     *   totalHours: sum('hours'),\n     *   averageScore: average('score')\n     * });\n     *\n     * const aggregateSnapshot = await aggregateQuery.get();\n     * const countOfDocs: number = aggregateSnapshot.data().countOfDocs;\n     * const totalHours: number = aggregateSnapshot.data().totalHours;\n     * const averageScore: number | null = aggregateSnapshot.data().averageScore;\n     * ```\n     */\n    aggregate(aggregateSpec) {\n        return new AggregateQuery(this, aggregateSpec);\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));\n    }\n    /**\n     * Returns the sorted array of inequality filter fields used in this query.\n     *\n     * @return An array of inequality filter fields sorted lexicographically by FieldPath.\n     */\n    getInequalityFilterFields() {\n        const inequalityFields = [];\n        for (const filter of this._queryOptions.filters) {\n            for (const subFilter of filter.getFlattenedFilters()) {\n                if (subFilter.isInequalityFilter()) {\n                    inequalityFields.push(subFilter.field);\n                }\n            }\n        }\n        return inequalityFields.sort((a, b) => a.compareTo(b));\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @internal\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n        // Add an implicit orderBy if the only cursor value is a DocumentSnapshot.\n        if (cursorValuesOrDocumentSnapshot.length !== 1 ||\n            !(cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot)) {\n            return this._queryOptions.fieldOrders;\n        }\n        const fieldOrders = this._queryOptions.fieldOrders.slice();\n        const fieldsNormalized = new Set([\n            ...fieldOrders.map(item => item.field.toString()),\n        ]);\n        /** The order of the implicit ordering always matches the last explicit order by. */\n        const lastDirection = fieldOrders.length === 0\n            ? directionOperators.ASC\n            : fieldOrders[fieldOrders.length - 1].direction;\n        /**\n         * Any inequality fields not explicitly ordered should be implicitly ordered in a\n         * lexicographical order. When there are multiple inequality filters on the same field, the\n         * field should be added only once.\n         * Note: getInequalityFilterFields function sorts the key field before\n         * other fields. However, we want the key field to be sorted last.\n         */\n        const inequalityFields = this.getInequalityFilterFields();\n        for (const field of inequalityFields) {\n            if (!fieldsNormalized.has(field.toString()) &&\n                !field.isEqual(path_1.FieldPath.documentId())) {\n                fieldOrders.push(new FieldOrder(field, lastDirection));\n                fieldsNormalized.add(field.toString());\n            }\n        }\n        // Add the document key field to the last if it is not explicitly ordered.\n        if (!fieldsNormalized.has(path_1.FieldPath.documentId().toString())) {\n            fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n        }\n        return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @internal\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n        let fieldValues;\n        if (cursorValuesOrDocumentSnapshot.length === 1 &&\n            cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot) {\n            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n        }\n        else {\n            fieldValues = cursorValuesOrDocumentSnapshot;\n        }\n        if (fieldValues.length > fieldOrders.length) {\n            throw new Error('Too many cursor values specified. The specified ' +\n                'values must match the orderBy() constraints of the query.');\n        }\n        const options = { values: [], before };\n        for (let i = 0; i < fieldValues.length; ++i) {\n            let fieldValue = fieldValues[i];\n            if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n                fieldValue = this.validateReference(fieldValue);\n            }\n            validateQueryValue(i, fieldValue, this._allowUndefined);\n            options.values.push(this._serializer.encodeValue(fieldValue));\n        }\n        return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     * @internal\n     */\n    validateReference(val) {\n        const basePath = this._queryOptions.allDescendants\n            ? this._queryOptions.parentPath\n            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n        let reference;\n        if (typeof val === 'string') {\n            const path = basePath.append(val);\n            if (this._queryOptions.allDescendants) {\n                if (!path.isDocument) {\n                    throw new Error('When querying a collection group and ordering by ' +\n                        'FieldPath.documentId(), the corresponding value must result in ' +\n                        `a valid document path, but '${val}' is not because it ` +\n                        'contains an odd number of segments.');\n                }\n            }\n            else if (val.indexOf('/') !== -1) {\n                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +\n                    `the corresponding value must be a plain document ID, but '${val}' ` +\n                    'contains a slash.');\n            }\n            reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n        }\n        else if (val instanceof DocumentReference) {\n            reference = val;\n            if (!basePath.isPrefixOf(reference._path)) {\n                throw new Error(`\"${reference.path}\" is not part of the query result set and ` +\n                    'cannot be used as a query boundary.');\n            }\n        }\n        else {\n            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +\n                `string or a DocumentReference, but was \"${val}\".`);\n        }\n        if (!this._queryOptions.allDescendants &&\n            reference._path.parent().compareTo(basePath) !== 0) {\n            throw new Error('Only a direct child can be used as a query boundary. ' +\n                `Found: \"${reference.path}\".`);\n        }\n        return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    startAt(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    startAfter(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    endBefore(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    endAt(...fieldValuesOrDocumentSnapshot) {\n        (0, validate_1.validateMinNumberOfArguments)('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     * ```\n     */\n    get() {\n        return this._get();\n    }\n    /**\n     * Plans and optionally executes this query. Returns a Promise that will be\n     * resolved with the planner information, statistics from the query execution (if any),\n     * and the query results (if any).\n     *\n     * @return A Promise that will be resolved with the planner information, statistics\n     *  from the query execution (if any), and the query results (if any).\n     */\n    explain(options) {\n        if (options === undefined) {\n            options = {};\n        }\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            let readTime;\n            let docs = null;\n            let metrics = null;\n            this._stream(undefined, options)\n                .on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            })\n                .on('data', data => {\n                if (data.readTime) {\n                    readTime = data.readTime;\n                }\n                if (data.document) {\n                    if (docs === null) {\n                        docs = [];\n                    }\n                    docs.push(data.document);\n                }\n                if (data.explainMetrics) {\n                    metrics = data.explainMetrics;\n                    if (docs === null && (metrics === null || metrics === void 0 ? void 0 : metrics.executionStats) !== null) {\n                        // This indicates that the query was executed, but no documents\n                        // had matched the query.\n                        docs = [];\n                    }\n                }\n            })\n                .on('end', () => {\n                if (metrics === null) {\n                    reject('No explain results.');\n                }\n                // Some explain queries will not have a snapshot associated with them.\n                let snapshot = null;\n                if (docs !== null) {\n                    if (this._queryOptions.limitType === LimitType.Last) {\n                        // The results for limitToLast queries need to be flipped since\n                        // we reversed the ordering constraints before sending the query\n                        // to the backend.\n                        docs.reverse();\n                    }\n                    snapshot = new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n                        const changes = [];\n                        for (let i = 0; i < docs.length; ++i) {\n                            changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                        }\n                        return changes;\n                    });\n                }\n                resolve(new query_profile_1.ExplainResults(metrics, snapshot));\n            });\n        });\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @internal\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     */\n    _get(transactionIdOrReadTime) {\n        const docs = [];\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            let readTime;\n            this._stream(transactionIdOrReadTime)\n                .on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            })\n                .on('data', result => {\n                readTime = result.readTime;\n                if (result.document) {\n                    docs.push(result.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n                    const changes = [];\n                    for (let i = 0; i < docs.length; ++i) {\n                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                    }\n                    return changes;\n                }));\n            });\n        });\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     * ```\n     */\n    stream() {\n        if (this._queryOptions.limitType === LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream();\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                callback(undefined, chunk.document);\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    /**\n     * Executes the query and streams the results as the following object:\n     * {document?: DocumentSnapshot, metrics?: ExplainMetrics}\n     *\n     * The stream surfaces documents one at a time as they are received from the\n     * server, and at the end, it will surface the metrics associated with\n     * executing the query.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.explainStream({analyze: true}).on('data', (data) => {\n     *   if (data.document) {\n     *     // Use data.document which is a DocumentSnapshot instance.\n     *     console.log(`Found document with name '${data.document.id}'`);\n     *     ++count;\n     *   }\n     *   if (data.metrics) {\n     *     // Use data.metrics which is an ExplainMetrics instance.\n     *   }\n     * }).on('end', () => {\n     *   console.log(`Received ${count} documents.`);\n     * });\n     * ```\n     */\n    explainStream(explainOptions) {\n        if (explainOptions === undefined) {\n            explainOptions = {};\n        }\n        if (this._queryOptions.limitType === LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.explain() instead.');\n        }\n        const responseStream = this._stream(undefined, explainOptions);\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                callback(undefined, {\n                    document: chunk.document,\n                    metrics: chunk.explainMetrics,\n                });\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     * @internal\n     */\n    toCursor(cursor) {\n        if (cursor) {\n            return cursor.before\n                ? { before: true, values: cursor.values }\n                : { values: cursor.values };\n        }\n        return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id or read time.\n     *\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @private\n     * @internal\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionIdOrReadTime, explainOptions) {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n        const structuredQuery = this.toStructuredQuery();\n        // For limitToLast queries, the structured query has to be translated to a version with\n        // reversed ordered, and flipped startAt/endAt to work properly.\n        if (this._queryOptions.limitType === LimitType.Last) {\n            if (!this._queryOptions.hasFieldOrders()) {\n                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n            }\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n                // Flip the orderBy directions since we want the last results\n                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n                return new FieldOrder(order.field, dir).toProto();\n            });\n            // Swap the cursors to match the now-flipped query ordering.\n            structuredQuery.startAt = this._queryOptions.endAt\n                ? this.toCursor({\n                    values: this._queryOptions.endAt.values,\n                    before: !this._queryOptions.endAt.before,\n                })\n                : undefined;\n            structuredQuery.endAt = this._queryOptions.startAt\n                ? this.toCursor({\n                    values: this._queryOptions.startAt.values,\n                    before: !this._queryOptions.startAt.before,\n                })\n                : undefined;\n        }\n        const runQueryRequest = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (transactionIdOrReadTime instanceof Uint8Array) {\n            runQueryRequest.transaction = transactionIdOrReadTime;\n        }\n        else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n            runQueryRequest.readTime =\n                transactionIdOrReadTime.toProto().timestampValue;\n        }\n        if (explainOptions) {\n            runQueryRequest.explainOptions = explainOptions;\n        }\n        return runQueryRequest;\n    }\n    /**\n     * Converts current Query to an IBundledQuery.\n     *\n     * @private\n     * @internal\n     */\n    _toBundledQuery() {\n        const projectId = this.firestore.projectId;\n        const databaseId = this.firestore.databaseId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId, databaseId);\n        const structuredQuery = this.toStructuredQuery();\n        const bundledQuery = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (this._queryOptions.limitType === LimitType.First) {\n            bundledQuery.limitType = 'FIRST';\n        }\n        else if (this._queryOptions.limitType === LimitType.Last) {\n            bundledQuery.limitType = 'LAST';\n        }\n        return bundledQuery;\n    }\n    toStructuredQuery() {\n        const structuredQuery = {\n            from: [{}],\n        };\n        if (this._queryOptions.allDescendants) {\n            structuredQuery.from[0].allDescendants = true;\n        }\n        // Kindless queries select all descendant documents, so we remove the\n        // collectionId field.\n        if (!this._queryOptions.kindless) {\n            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n        }\n        if (this._queryOptions.filters.length >= 1) {\n            structuredQuery.where = new CompositeFilterInternal(this._queryOptions.filters, 'AND').toProto();\n        }\n        if (this._queryOptions.hasFieldOrders()) {\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n        }\n        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n        if (this._queryOptions.limit) {\n            structuredQuery.limit = { value: this._queryOptions.limit };\n        }\n        structuredQuery.offset = this._queryOptions.offset;\n        structuredQuery.select = this._queryOptions.projection;\n        return structuredQuery;\n    }\n    /**\n     * @internal\n     * @private\n     * This method exists solely to enable unit tests to mock it.\n     */\n    _isPermanentRpcError(err, methodName) {\n        return (0, util_1.isPermanentRpcError)(err, methodName);\n    }\n    /**\n     * @internal\n     * @private\n     */\n    _hasRetryTimedOut(methodName, startTime) {\n        const totalTimeout = (0, util_1.getTotalTimeout)(methodName);\n        if (totalTimeout === 0) {\n            return false;\n        }\n        return Date.now() - startTime >= totalTimeout;\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @private\n     * @internal\n     * @returns A stream of document results.\n     */\n    _stream(transactionIdOrReadTime, explainOptions) {\n        const tag = (0, util_1.requestTag)();\n        const startTime = Date.now();\n        const isExplain = explainOptions !== undefined;\n        let lastReceivedDocument = null;\n        let backendStream;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                if (proto === NOOP_MESSAGE) {\n                    callback(undefined);\n                    return;\n                }\n                const output = {};\n                if (proto.readTime) {\n                    output.readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                }\n                if (proto.document) {\n                    const document = this.firestore.snapshot_(proto.document, proto.readTime);\n                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n                    // Recreate the QueryDocumentSnapshot with the DocumentReference\n                    // containing the original converter.\n                    finalDoc.fieldsProto = document._fieldsProto;\n                    finalDoc.readTime = document.readTime;\n                    finalDoc.createTime = document.createTime;\n                    finalDoc.updateTime = document.updateTime;\n                    lastReceivedDocument = finalDoc.build();\n                    output.document = lastReceivedDocument;\n                }\n                if (proto.explainMetrics) {\n                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, this._serializer);\n                }\n                callback(undefined, output);\n                if (proto.done) {\n                    (0, logger_1.logger)('Query._stream', tag, 'Trigger Logical Termination.');\n                    backendStream.unpipe(stream);\n                    backendStream.resume();\n                    backendStream.end();\n                    stream.end();\n                }\n            },\n        });\n        this.firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            let request = this.toProto(transactionIdOrReadTime, explainOptions);\n            let streamActive;\n            do {\n                streamActive = new util_1.Deferred();\n                const methodName = 'runQuery';\n                backendStream = await this._firestore.requestStream(methodName, \n                /* bidirectional= */ false, request, tag);\n                backendStream.on('error', err => {\n                    backendStream.unpipe(stream);\n                    // If a non-transactional query failed, attempt to restart.\n                    // Transactional queries are retried via the transaction runner.\n                    // Explain queries are not retried with a cursor. That would produce\n                    // incorrect/partial profiling results.\n                    if (!isExplain &&\n                        !transactionIdOrReadTime &&\n                        !this._isPermanentRpcError(err, 'runQuery')) {\n                        (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error:', err);\n                        // Enqueue a \"no-op\" write into the stream and wait for it to be\n                        // read by the downstream consumer. This ensures that all enqueued\n                        // results in the stream are consumed, which will give us an accurate\n                        // value for `lastReceivedDocument`.\n                        stream.write(NOOP_MESSAGE, () => {\n                            if (this._hasRetryTimedOut(methodName, startTime)) {\n                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error but the total retry timeout has exceeded.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                            else if (lastReceivedDocument) {\n                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error and progress was made receiving ' +\n                                    'documents, so the stream is being retried.');\n                                // Restart the query but use the last document we received as\n                                // the query cursor. Note that we do not use backoff here. The\n                                // call to `requestStream()` will backoff should the restart\n                                // fail before delivering any results.\n                                if (this._queryOptions.requireConsistency) {\n                                    request = this.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                                }\n                                else {\n                                    request = this.startAfter(lastReceivedDocument).toProto();\n                                }\n                                // Set lastReceivedDocument to null before each retry attempt to ensure the retry makes progress\n                                lastReceivedDocument = null;\n                                streamActive.resolve(/* active= */ true);\n                            }\n                            else {\n                                (0, logger_1.logger)('Query._stream', tag, 'Query failed with retryable stream error however no progress was made receiving ' +\n                                    'documents, so the stream is being closed.');\n                                stream.destroy(err);\n                                streamActive.resolve(/* active= */ false);\n                            }\n                        });\n                    }\n                    else {\n                        (0, logger_1.logger)('Query._stream', tag, 'Query failed with stream error:', err);\n                        stream.destroy(err);\n                        streamActive.resolve(/* active= */ false);\n                    }\n                });\n                backendStream.on('end', () => {\n                    streamActive.resolve(/* active= */ false);\n                });\n                backendStream.resume();\n                backendStream.pipe(stream);\n            } while (await streamActive.promise);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * ```\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     * ```\n     */\n    onSnapshot(onNext, onError) {\n        (0, validate_1.validateFunction)('onNext', onNext);\n        (0, validate_1.validateFunction)('onError', onError, { optional: true });\n        const watch = new (require('./watch').QueryWatch)(this.firestore, this, this._queryOptions.converter);\n        return watch.onSnapshot((readTime, size, docs, changes) => {\n            onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n        }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     * @internal\n     */\n    comparator() {\n        return (doc1, doc2) => {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = this._queryOptions.hasFieldOrders()\n                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction\n                : 'ASCENDING';\n            const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n            for (const orderBy of orderBys) {\n                let comp;\n                if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n                    comp = doc1.ref._path.compareTo(doc2.ref._path);\n                }\n                else {\n                    const v1 = doc1.protoField(orderBy.field);\n                    const v2 = doc2.protoField(orderBy.field);\n                    if (v1 === undefined || v2 === undefined) {\n                        throw new Error('Trying to compare documents on fields that ' +\n                            \"don't exist. Please include the fields you are ordering on \" +\n                            'in your select() call.');\n                    }\n                    comp = (0, order_1.compare)(v1, v2);\n                }\n                if (comp !== 0) {\n                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n                    return direction * comp;\n                }\n            }\n            return 0;\n        };\n    }\n    /**\n     * Applies a custom data converter to this Query, allowing you to use your\n     * own custom model objects with Firestore. When you call get() on the\n     * returned Query, the provided converter will convert between Firestore\n     * data of type `NewDbModelType` and your custom type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A Query that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)()));\n    }\n}\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class CollectionReference\n * @extends Query\n */\nclass CollectionReference extends Query {\n    /**\n     * @private\n     *\n     * @param firestore The Firestore Database client.\n     * @param path The Path of this collection.\n     */\n    constructor(firestore, path, converter) {\n        super(firestore, QueryOptions.forCollectionQuery(path, converter));\n    }\n    /**\n     * Returns a resource path for this collection.\n     * @private\n     * @internal\n     */\n    get _resourcePath() {\n        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    }\n    /**\n     * The last path element of the referenced collection.\n     *\n     * @type {string}\n     * @name CollectionReference#id\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\n     * ```\n     */\n    get id() {\n        return this._queryOptions.collectionId;\n    }\n    /**\n     * A reference to the containing Document if this is a subcollection, else\n     * null.\n     *\n     * @type {DocumentReference|null}\n     * @name CollectionReference#parent\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * let documentRef = collectionRef.parent;\n     * console.log(`Parent name: ${documentRef.path}`);\n     * ```\n     */\n    get parent() {\n        if (this._queryOptions.parentPath.isDocument) {\n            return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n        }\n        return null;\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name CollectionReference#path\n     * @readonly\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\n     * ```\n     */\n    get path() {\n        return this._resourcePath.relativeName;\n    }\n    /**\n     * Retrieves the list of documents in this collection.\n     *\n     * The document references returned may include references to \"missing\n     * documents\", i.e. document locations that have no document present but\n     * which contain subcollections with documents. Attempting to read such a\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n     * `DocumentSnapshot` whose `.exists` property is false.\n     *\n     * @return {Promise<DocumentReference[]>} The list of documents in this\n     * collection.\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     *\n     * return collectionRef.listDocuments().then(documentRefs => {\n     *    return firestore.getAll(...documentRefs);\n     * }).then(documentSnapshots => {\n     *    for (let documentSnapshot of documentSnapshots) {\n     *       if (documentSnapshot.exists) {\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\n     *       } else {\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\n     *       }\n     *    }\n     * });\n     * ```\n     */\n    listDocuments() {\n        const tag = (0, util_1.requestTag)();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId, this.firestore.databaseId);\n            const request = {\n                parent: parentPath.formattedName,\n                collectionId: this.id,\n                showMissing: true,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n                mask: { fieldPaths: [] },\n            };\n            return this.firestore\n                .request('listDocuments', request, tag)\n                .then(documents => {\n                // Note that the backend already orders these documents by name,\n                // so we do not need to manually sort them.\n                return documents.map(doc => {\n                    const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n                    return this.doc(path.id);\n                });\n            });\n        });\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path. If no path is specified, an\n     * automatically-generated unique ID will be used for the returned\n     * DocumentReference.\n     *\n     * @param {string=} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The `DocumentReference`\n     * instance.\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     * let documentRefWithName = collectionRef.doc('doc');\n     * let documentRefWithAutoId = collectionRef.doc();\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n     * ```\n     */\n    doc(documentPath) {\n        if (arguments.length === 0) {\n            documentPath = (0, util_1.autoId)();\n        }\n        else {\n            (0, path_1.validateResourcePath)('documentPath', documentPath);\n        }\n        const path = this._resourcePath.append(documentPath);\n        if (!path.isDocument) {\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n        }\n        return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n    }\n    /**\n     * Add a new document to this collection with the specified data, assigning\n     * it a document ID automatically.\n     *\n     * @param {DocumentData} data An Object containing the data for the new\n     * document.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\n     * [DocumentReference]{@link DocumentReference} pointing to the\n     * newly created document.\n     *\n     * @example\n     * ```\n     * let collectionRef = firestore.collection('col');\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name: ${documentReference.id}`);\n     * });\n     * ```\n     */\n    add(data) {\n        const firestoreData = this._queryOptions.converter.toFirestore(data);\n        (0, write_batch_1.validateDocumentData)('data', firestoreData, \n        /*allowDeletes=*/ false, this._allowUndefined);\n        const documentRef = this.doc();\n        return documentRef.create(data).then(() => documentRef);\n    }\n    /**\n     * Returns true if this `CollectionReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `CollectionReference` is equal to the\n     * provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof CollectionReference && super.isEqual(other)));\n    }\n    /**\n     * Applies a custom data converter to this CollectionReference, allowing you\n     * to use your own custom model objects with Firestore. When you call add() on\n     * the returned CollectionReference instance, the provided converter will\n     * convert between Firestore data of type `NewDbModelType` and your custom\n     * type `NewAppModelType`.\n     *\n     * Using the converter allows you to specify generic type arguments when\n     * storing and retrieving objects from Firestore.\n     *\n     * Passing in `null` as the converter parameter removes the current\n     * converter.\n     *\n     * @example\n     * ```\n     * class Post {\n     *   constructor(readonly title: string, readonly author: string) {}\n     *\n     *   toString(): string {\n     *     return this.title + ', by ' + this.author;\n     *   }\n     * }\n     *\n     * const postConverter = {\n     *   toFirestore(post: Post): FirebaseFirestore.DocumentData {\n     *     return {title: post.title, author: post.author};\n     *   },\n     *   fromFirestore(\n     *     snapshot: FirebaseFirestore.QueryDocumentSnapshot\n     *   ): Post {\n     *     const data = snapshot.data();\n     *     return new Post(data.title, data.author);\n     *   }\n     * };\n     *\n     * const postSnap = await Firestore()\n     *   .collection('posts')\n     *   .withConverter(postConverter)\n     *   .doc().get();\n     * const post = postSnap.data();\n     * if (post !== undefined) {\n     *   post.title; // string\n     *   post.toString(); // Should be defined\n     *   post.someNonExistentProperty; // TS error\n     * }\n     *\n     * ```\n     * @param {FirestoreDataConverter | null} converter Converts objects to and\n     * from Firestore. Passing in `null` removes the current converter.\n     * @return A CollectionReference that uses the provided converter.\n     */\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : (0, types_1.defaultConverter)());\n    }\n}\nexports.CollectionReference = CollectionReference;\n/**\n * A query that calculates aggregations over an underlying query.\n */\nclass AggregateQuery {\n    /**\n     * @internal\n     * @param _query The query whose aggregations will be calculated by this\n     * object.\n     * @param _aggregates The aggregations that will be performed by this query.\n     */\n    constructor(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _query, _aggregates) {\n        this._query = _query;\n        this._aggregates = _aggregates;\n        this.clientAliasToServerAliasMap = {};\n        this.serverAliasToClientAliasMap = {};\n        // Client-side aliases may be too long and exceed the 1500-byte string size limit.\n        // Such long strings do not need to be transferred over the wire either.\n        // The client maps the user's alias to a short form alias and send that to the server.\n        let aggregationNum = 0;\n        for (const clientAlias in this._aggregates) {\n            if (Object.prototype.hasOwnProperty.call(this._aggregates, clientAlias)) {\n                const serverAlias = `aggregate_${aggregationNum++}`;\n                this.clientAliasToServerAliasMap[clientAlias] = serverAlias;\n                this.serverAliasToClientAliasMap[serverAlias] = clientAlias;\n            }\n        }\n    }\n    /** The query whose aggregations will be calculated by this object. */\n    get query() {\n        return this._query;\n    }\n    /**\n     * Executes this query.\n     *\n     * @return A promise that will be resolved with the results of the query.\n     */\n    get() {\n        return this._get();\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @internal\n     * @param {bytes=} transactionId A transaction ID.\n     */\n    _get(transactionIdOrReadTime) {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let result = null;\n        return new Promise((resolve, reject) => {\n            const stream = this._stream(transactionIdOrReadTime);\n            stream.on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            });\n            stream.on('data', data => {\n                if (data.aggregationResult) {\n                    result = data.aggregationResult;\n                }\n            });\n            stream.on('end', () => {\n                stream.destroy();\n                if (result === null) {\n                    reject(Error('RunAggregationQueryResponse is missing result'));\n                }\n                resolve(result);\n            });\n        });\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @private\n     * @internal\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @param explainOptions Options to use for explaining the query (if any).\n     * @returns A stream of document results.\n     */\n    _stream(transactionIdOrReadTime, explainOptions) {\n        const tag = (0, util_1.requestTag)();\n        const firestore = this._query.firestore;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                const output = {};\n                if (proto.result) {\n                    const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                    const data = this.decodeResult(proto.result);\n                    output.aggregationResult = new AggregateQuerySnapshot(this, readTime, data);\n                }\n                if (proto.explainMetrics) {\n                    output.explainMetrics = query_profile_1.ExplainMetrics._fromProto(proto.explainMetrics, firestore._serializer);\n                }\n                callback(undefined, output);\n            },\n        });\n        firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            const request = this.toProto(transactionIdOrReadTime, explainOptions);\n            const backendStream = await firestore.requestStream('runAggregationQuery', \n            /* bidirectional= */ false, request, tag);\n            stream.on('close', () => {\n                backendStream.resume();\n                backendStream.end();\n            });\n            backendStream.on('error', err => {\n                // TODO(group-by) When group-by queries are supported for aggregates\n                // consider implementing retries if the stream is making progress\n                // receiving results for groups. See the use of lastReceivedDocument\n                // in the retry strategy for runQuery.\n                // Also note that explain queries should not be retried.\n                backendStream.unpipe(stream);\n                (0, logger_1.logger)('AggregateQuery._stream', tag, 'AggregateQuery failed with stream error:', err);\n                stream.destroy(err);\n            });\n            backendStream.resume();\n            backendStream.pipe(stream);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Internal method to decode values within result.\n     * @private\n     */\n    decodeResult(proto) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data = {};\n        const fields = proto.aggregateFields;\n        if (fields) {\n            const serializer = this._query.firestore._serializer;\n            for (const prop of Object.keys(fields)) {\n                const alias = this.serverAliasToClientAliasMap[prop];\n                assert(alias !== null && alias !== undefined, `'${prop}' not present in server-client alias mapping.`);\n                if (this._aggregates[alias] === undefined) {\n                    throw new Error(`Unexpected alias [${prop}] in result aggregate result`);\n                }\n                data[alias] = serializer.decodeValue(fields[prop]);\n            }\n        }\n        return data;\n    }\n    /**\n     * Internal method for serializing a query to its RunAggregationQuery proto\n     * representation with an optional transaction id.\n     *\n     * @private\n     * @internal\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionIdOrReadTime, explainOptions) {\n        const queryProto = this._query.toProto();\n        const runQueryRequest = {\n            parent: queryProto.parent,\n            structuredAggregationQuery: {\n                structuredQuery: queryProto.structuredQuery,\n                aggregations: (0, util_1.mapToArray)(this._aggregates, (aggregate, clientAlias) => {\n                    const serverAlias = this.clientAliasToServerAliasMap[clientAlias];\n                    assert(serverAlias !== null && serverAlias !== undefined, `'${clientAlias}' not present in client-server alias mapping.`);\n                    return new aggregate_1.Aggregate(serverAlias, aggregate.aggregateType, aggregate._field).toProto();\n                }),\n            },\n        };\n        if (transactionIdOrReadTime instanceof Uint8Array) {\n            runQueryRequest.transaction = transactionIdOrReadTime;\n        }\n        else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n            runQueryRequest.readTime = transactionIdOrReadTime;\n        }\n        if (explainOptions) {\n            runQueryRequest.explainOptions = explainOptions;\n        }\n        return runQueryRequest;\n    }\n    /**\n     * Compares this object with the given object for equality.\n     *\n     * This object is considered \"equal\" to the other object if and only if\n     * `other` performs the same aggregations as this `AggregateQuery` and\n     * the underlying Query of `other` compares equal to that of this object\n     * using `Query.isEqual()`.\n     *\n     * @param other The object to compare to this object for equality.\n     * @return `true` if this object is \"equal\" to the given object, as\n     * defined above, or `false` otherwise.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof AggregateQuery)) {\n            return false;\n        }\n        if (!this.query.isEqual(other.query)) {\n            return false;\n        }\n        return deepEqual(this._aggregates, other._aggregates);\n    }\n    /**\n     * Plans and optionally executes this query. Returns a Promise that will be\n     * resolved with the planner information, statistics from the query\n     * execution (if any), and the query results (if any).\n     *\n     * @return A Promise that will be resolved with the planner information,\n     * statistics from the query execution (if any), and the query results (if any).\n     */\n    explain(options) {\n        if (options === undefined) {\n            options = {};\n        }\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let metrics = null;\n        let aggregationResult = null;\n        return new Promise((resolve, reject) => {\n            const stream = this._stream(undefined, options);\n            stream.on('error', err => {\n                reject((0, util_1.wrapError)(err, stack));\n            });\n            stream.on('data', data => {\n                if (data.aggregationResult) {\n                    aggregationResult = data.aggregationResult;\n                }\n                if (data.explainMetrics) {\n                    metrics = data.explainMetrics;\n                }\n            });\n            stream.on('end', () => {\n                stream.destroy();\n                if (metrics === null) {\n                    reject('No explain results.');\n                }\n                resolve(new query_profile_1.ExplainResults(metrics, aggregationResult));\n            });\n        });\n    }\n}\nexports.AggregateQuery = AggregateQuery;\n/**\n * The results of executing an aggregation query.\n */\nclass AggregateQuerySnapshot {\n    /**\n     * @internal\n     *\n     * @param _query The query that was executed to produce this result.\n     * @param _readTime The time this snapshot was read.\n     * @param _data The results of the aggregations performed over the underlying\n     * query.\n     */\n    constructor(_query, _readTime, _data) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._data = _data;\n    }\n    /** The query that was executed to produce this result. */\n    get query() {\n        return this._query;\n    }\n    /** The time this snapshot was read. */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns the results of the aggregations performed over the underlying\n     * query.\n     *\n     * The keys of the returned object will be the same as those of the\n     * `AggregateSpec` object specified to the aggregation method, and the\n     * values will be the corresponding aggregation result.\n     *\n     * @returns The results of the aggregations performed over the underlying\n     * query.\n     */\n    data() {\n        return this._data;\n    }\n    /**\n     * Compares this object with the given object for equality.\n     *\n     * Two `AggregateQuerySnapshot` instances are considered \"equal\" if they\n     * have the same data and their underlying queries compare \"equal\" using\n     * `AggregateQuery.isEqual()`.\n     *\n     * @param other The object to compare to this object for equality.\n     * @return `true` if this object is \"equal\" to the given object, as\n     * defined above, or `false` otherwise.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof AggregateQuerySnapshot)) {\n            return false;\n        }\n        // Since the read time is different on every read, we explicitly ignore all\n        // document metadata in this comparison, just like\n        // `DocumentSnapshot.isEqual()` does.\n        if (!this.query.isEqual(other.query)) {\n            return false;\n        }\n        return deepEqual(this._data, other._data);\n    }\n}\nexports.AggregateQuerySnapshot = AggregateQuerySnapshot;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOrder(arg, op) {\n    // For backwards compatibility, we support both lower and uppercase values.\n    op = typeof op === 'string' ? op.toLowerCase() : op;\n    (0, validate_1.validateEnumValue)(arg, op, Object.keys(directionOperators), { optional: true });\n    return op;\n}\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOperator(arg, op, fieldValue) {\n    // For backwards compatibility, we support both `=` and `==` for \"equals\".\n    if (op === '=') {\n        op = '==';\n    }\n    (0, validate_1.validateEnumValue)(arg, op, Object.keys(comparisonOperators));\n    if (typeof fieldValue === 'number' &&\n        isNaN(fieldValue) &&\n        op !== '==' &&\n        op !== '!=') {\n        throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on NaN.\");\n    }\n    if (fieldValue === null && op !== '==' && op !== '!=') {\n        throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on Null.\");\n    }\n    return op;\n}\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @return the DocumentReference if valid\n */\nfunction validateDocumentReference(arg, value) {\n    if (!(value instanceof DocumentReference)) {\n        throw new Error((0, validate_1.invalidArgumentMessage)(arg, 'DocumentReference'));\n    }\n    return value;\n}\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\nfunction validateQueryValue(arg, value, allowUndefined) {\n    (0, serializer_1.validateUserInput)(arg, value, 'query constraint', {\n        allowDeletes: 'none',\n        allowTransforms: false,\n        allowUndefined,\n    });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @internal\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\nfunction isArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n * @internal\n */\nfunction coalesce(...values) {\n    return values.find(value => value !== undefined);\n}\n//# sourceMappingURL=reference.js.map"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIE,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACT,UAAU;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIY,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACX,KAAK,CAACY,YAAY;EAClC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,EAAEA,CAAA,EAAG;IACL,OAAO,IAAI,CAACb,KAAK,CAACa,EAAE;EACxB;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIC,aAAaA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACd,KAAK;EACrB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIe,MAAMA,CAAA,EAAG;IACT,OAAO,IAAIhD,mBAAmB,CAAC,IAAI,CAACgC,UAAU,EAAE,IAAI,CAACC,KAAK,CAACe,MAAM,CAAC,CAAC,EAAE,IAAI,CAACd,UAAU,CAAC;EACzF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIe,GAAGA,CAAA,EAAG;IACF,OAAO,IAAI,CAACjB,UAAU,CAACkB,MAAM,CAAC,IAAI,CAAC,CAACC,IAAI,CAACC,IAAA;MAAA,IAAC,CAACC,MAAM,CAAC,GAAAD,IAAA;MAAA,OAAKC,MAAM;IAAA,EAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAACC,cAAc,EAAE;IACvB,CAAC,CAAC,EAAEzC,MAAM,CAAC0C,oBAAoB,EAAE,gBAAgB,EAAED,cAAc,CAAC;IAClE,MAAMX,IAAI,GAAG,IAAI,CAACX,KAAK,CAA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CAACrH,KAAK,CAAC;EAC1C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,aAAa,CAAC;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI4B,WAAWA,CAACmH,MAAM,EAAEC,SAAS,EAAEC,KAAK,EAAE7C,IAAI,EAAE8C,OAAO,EAAE;IACjD,IAAI,CAACH,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,oBAAoB,GAAG,IAAI;IAChC,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACD,KAAK,GAAGjD,IAAI;IACjB,IAAI,CAACkD,QAAQ,GAAGJ,OAAO;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIK,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACR,MAAM;EACtB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI3C,IAAIA,CAAA,EAAG;IACP,IAAI,IAAI,CAAC+C,iBAAiB,EAAE;MACxB,OAAO,IAAI,CAACA,iBAAiB;IACjC;IACA,IAAI,CAACA,iBAAiB,GAAG,IAAI,CAACE,KAAK,CAAC,CAAC;IACrC,IAAI,CAACA,KAAK,GAAG,IAAI;IACjB,OAAO,IAAI,CAACF,iBAAiB;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAIK,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACP,KAAK,KAAK,CAAC;EAC3B;EACA;AACJ;AACA;AAC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"},"metadata":{},"sourceType":"script","externalDependencies":[]}